<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[还不了解Calendar？实现自定义Android日历，看这篇就够了]]></title>
      <url>%2F2016%2F10%2F02%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2F%E8%BF%98%E4%B8%8D%E4%BA%86%E8%A7%A3Calendar%EF%BC%9F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89Android%E6%97%A5%E5%8E%86%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
      <content type="text"><![CDATA[背景介绍日历对我的生活而言是一个容易被忽视，而又十分重要的东西。在Android中，我们也常常需要操作日历去实现一些需求。比如根据日期获取对应数据，或者承载了一些需求的自定义日历。为了方便对日期的操作，诞生了Calendar 类。这大大简化了我们的计算。事实上，我们只需要知道如何操作Calendar就行了。本篇我们将一起来了解下Calendar，并且实现一个自定义日历。 方便的Calendar类Calendar是干什么的？ The Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week. 上面是Android文档中对Calendar是什么的简单介绍。大概的意思就是说，Calendar是一个抽象类。它提供了一些用于一个具体时间和Calendar的字段(比如，YEAR、MONTH、DAY_OF_MONTH、HOUR等)互相转换的方法，以及对Calendar的字段的操作方法(比如，获取下一周的日期)。综上所述，Calendar就是一个操作日历的工具类。 Calendar的使用获得一个Calendar实例12345678910111213Calendar calendar = Calendar.getInstance(); //这个方法获取到的是默认的Calendar实例。//一般使用默认的就好，它会根据app运行的时区、语言环境自动创建相应的Calendar实例。Calendar calendar = Calendar.getInstance(Locale.CHINA); //根据Locale来获取相应的Calendar实例。Calendar calendar = Calendar.getInstance(TimeZone.getDefaultRef(), Locale.CHINA);//根据TimeZone和Locale来获取相应的Calendar实例。//这些方法最终调用的都是createCalendar()private static Calendar createCalendar(TimeZone zone, Locale aLocale) &#123; return new GregorianCalendar(zone, aLocale); //Android中使用了GregorianCalendar。 //注意这里每次都是new一个新的Calendar实例。&#125; 挑几个方法特别说明下 set(f, value) 调用该方法可以把Calendar的某个字段f的值设置为指定值value。 这里需要注意：DAY_OF_MONTH字段是从1开始，如果设置0，表示上个月的最后一天；MONTH字段是从0开始，如果设置12，表示下一年的第一个月。 set()方法设置后，仅仅是改变了Calendar的指定字段的值，但是Calendar表示的日期并没有重新计算。Calendar将会在下次调用get()、getTime()、getTimeInMillis()、add()或roll()方法时，真实的重新计算日期。 add(f, delta)效果等同于调用了set(f, get(f) + delta)l。 roll(f, delta)效果和add()有些类似。但是它的作用范围限制在f字段上，不会影响到其它字段。举个栗子。 12345Calendar calendar = Calendar.getInstance();calendar.set(2016,1,1);calendar.roll(Calendar.DAY_OF_MONTH, 32);SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");System.out.println(dateFormat.format(calendar.getTime())); 输出：12016-01-01 看出来没？它只在DAY_OF_MONTH这个字段里循环，而不会导致其它字段发生变化。 getFirstDayOfWeek()这个方法用于获取一个周的第一天是周几。一般一个周的第一天是星期天，但法国的是星期一。 clone()这个方法是由Clonable接口提供的。可以克隆一个Calendar实例。这很有用，可以避免混乱的操作Calendar。 其它方法的使用请点击链接看Calendar的方法使用大全 几个特殊的规则 GregorianCalendar的时间原点是1970-01-01 00:00:00.000。所以通过getTimeInMillis()获得的时间戳就是时间原点的偏移量。 日期大小规则Thus, 23:59 on Dec 31, 1999 &lt; 00:00 on Jan 1, 2000 &lt; 00:01 on Jan 1, 2000.12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm. 撸个自定义日历上个效果图，比较简陋，各位看官见谅啊。主要是为了说明下Calendar的使用。主要使用了ViewPager + Fragment + RecyclerView完成。但这不是重点。重点是Calendar！所以我就放核心的代码。其它部分和大家平时使用的ViewPager + Fragment + RecyclerView也都差不多。且看～1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192protected void initData() &#123; dateList.clear(); initialDate = (Date) getArguments().getSerializable(KEY_DATE); //获取传过来的Date，用于确定初始的calendar Calendar calendar = Calendar.getInstance(Locale.CHINA); //获取China区Calendar实例，实际是GregorianCalendar的一个实例 calendar.setTime(initialDate); //初始化日期 int maxDay = calendar.getActualMaximum(Calendar.DAY_OF_MONTH); //获得当前日期所在月份有多少天（或者说day的最大值)，用于后面的计算 Calendar calendarClone = (Calendar) calendar.clone(); //克隆一个Calendar再进行操作，避免造成混乱 calendarClone.set(Calendar.DAY_OF_MONTH, 1); //将日期调到当前月份的第一天 int startDayOfWeek = calendarClone.get(Calendar.DAY_OF_WEEK); //获得当前日期所在月份的第一天是星期几 calendarClone.set(Calendar.DAY_OF_MONTH, maxDay); //将日期调到当前月份的最后一天 int endDayOfWeek = calendarClone.get(Calendar.DAY_OF_WEEK); //获得当前日期所在月份的最后一天是星期几 /** * 计算上一个月在本月日历页出现的那几天. * 比如，startDayOfWeek = 3，表示当月第一天是星期二，所以日历向前会空出2天的位置，那么让上月的最后两天显示在星期日和星期一的位置上. */ int startEmptyCount = startDayOfWeek - 1; //上月在本月日历页因该出现的天数。 Calendar preCalendar = (Calendar) calendar.clone(); //克隆一份再操作 preCalendar.set(Calendar.DAY_OF_MONTH, 1); //将日期调到当月第一天 preCalendar.add(Calendar.DAY_OF_MONTH, -startEmptyCount); //向前推移startEmptyCount天 for (int i = 0; i &lt; startEmptyCount; i++) &#123; DateInfo dateInfo = new DateInfo(); //使用DateInfo来储存所需的相关信息 dateInfo.setDate(preCalendar.getTime()); dateInfo.setType(DateInfo.PRE_MONTH); //标记日期信息的类型为上个月 dateList.add(dateInfo); //将日期添加到数组中 preCalendar.add(Calendar.DAY_OF_MONTH, 1); //向后推移一天 &#125; /** * 计算当月的每一天日期 */ calendar.set(Calendar.DAY_OF_MONTH, 1); //由于是获取当月日期信息，所以直接操作当月Calendar即可。将日期调为当月第一天 for (int i = 0; i &lt; maxDay; i++) &#123; DateInfo dateInfo = new DateInfo(); dateInfo.setDate(calendar.getTime()); dateInfo.setType(DateInfo.CURRENT_MONTH); //标记日期信息的类型为当月 dateList.add(dateInfo); calendar.add(Calendar.DAY_OF_MONTH, 1); //向后推移一天 &#125; /** * 计算下月在本月日历页出现的那几天。 * 比如，endDayOfWeek = 6，表示当月第二天是星期五，所以日历向后会空出1天的位置，那么让下月的第一天显示在星期六的位置上。 */ int endEmptyCount = 7 - endDayOfWeek; //下月在本月日历页上因该出现的天数 Calendar afterCalendar = (Calendar) calendar.clone(); //同样，克隆一份在操作 for (int i = 0; i &lt; endEmptyCount; i++) &#123; DateInfo dateInfo = new DateInfo(); dateInfo.setDate(afterCalendar.getTime()); dateInfo.setType(DateInfo.AFTER_MONTH); //将DateInfo类型标记为下个月 dateList.add(dateInfo); afterCalendar.add(Calendar.DAY_OF_MONTH, 1); //向后推移一天 &#125; &#125; //DateInfo有必要放一下。不过这仅代表我的思路。 private static class DateInfo &#123; private static final int PRE_MONTH = 1; private static final int CURRENT_MONTH = PRE_MONTH + 1; private static final int AFTER_MONTH = CURRENT_MONTH + 1; private static final int WEEK_TITLE = AFTER_MONTH + 1; private Date date; private int type; private String weekTitle; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; public String getWeekTitle() &#123; return weekTitle; &#125; public void setWeekTitle(String weekTitle) &#123; this.weekTitle = weekTitle; &#125; &#125; 后面只需要把dateList 中的数据放到RecyclerView中就可以。 总结到此想必大家也对Calendar有了个基本点的了解。平时用的比较多的就是get(),getTime(),set(),add(),roll()等方法，我在上面提了几个特殊点的。其它的可以到上面提到那个链接里熟悉，写的比较详细的。这波【农夫山泉】我就不搬了。 参考链接 Android文档 How Soft Works-Calendar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么？IOS的专利？Android也能流畅实现毛玻璃效果(高斯模糊)效果]]></title>
      <url>%2F2016%2F09%2F20%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2F%E4%BB%80%E4%B9%88%EF%BC%9FIOS%E7%9A%84%E4%B8%93%E5%88%A9%EF%BC%9FAndroid%E4%B9%9F%E8%83%BD%E6%B5%81%E7%95%85%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C(%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A)%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[背景介绍上图就是我们在IOS设备上经常能够见到的毛玻璃(高斯模糊)效果。不得不说，这种效果在适合的场景下使用，能够获得绝佳的美感。但是鉴于Android设备性能和兼容性问题，我们通常很难在Android设备上见到这种效果。但这并不是IOS的专利效果，Android也能轻松流畅的实现。本篇文章将会详细的讲解如何实现。 Android中的高斯模糊我为什么选择RenderScript实现高斯模糊目前Android设备上实现高斯模糊效果的方式通常有： 云端处理，移动客户端直接从网络获取处理好的图片。这种方式局限性很大。 FastBlur等开源库。这种方式兼容性不错，但是效率极低。 c实现。不懂c的理解困难😂。 OpenGL实现。效果很好，但电量和内存消耗比较高。 RenderScript实现。效果略弱于第4种，但是使用方便，速度很快，性能消耗在可接受范围内，加上Google的兼容性解决方案，可以说是能够作为优先考虑的方式。 RenderScript RenderScript主要在android中的对图形进行处理，RenderScript采用C99语法进行编写，主要优势在于性能较高。在Api11的时候被加入到Android中。同时，Google提供了android.support.v8.renderscript兼容包，能够实现更低版本的兼容。 RenderScript提供了一个用于实现高斯模糊的封装类ScriptIntrinsicBlur ，这货在Api17才被收编Android所以在不使用兼容包的情况下只能兼容到4.2的设备。但是，我们有兼容包啊😉向下兼容不是梦。 准备阶段引入兼容包方法很简单，只需在build.gradle中加入:12345678defaultConfig &#123; 。 。 。 //就是这么简单😉 renderscriptTargetApi 19 renderscriptSupportModeEnabled true &#125; 你以为这样就好了？nonono。由于一些坑人的厂商会深度定制Android系统，所以一些必要的依赖文件会被它们直接去掉！！😂这导致一些型号的设备上调用RenderScriptd的部分方法时会报错。所以我们得加上这些可能丢失的文件。其实也简单，打开android_sdk/build-tools/选择19以上版本/renderscript/lib/packaged我们可以看见3个包含.os文件的文件夹。 直接复制这三个文件加到项目工程的jniLibs 包下。什么？找不见jniLibs包？自己建一个喽。 注意，这时候，我们很可能遇到一个奔溃，找不到.os文件😱。莫慌莫慌…在build.gradle的android{}中加入：12345sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; &#125; 没完没了!最后一步😒只针对使用的混淆的同学，需要在混淆中加入：1-keep class android.support.v8.renderscript.** &#123; *; &#125; 实现高斯模糊终于可以开始写代码了。先来看看效果。下图高斯模糊半径逐渐增大的效果，请忽略渣渣录屏效果😏 将ScriptIntrinsicBlur封装成工具类。咱们代码里接着款😎1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import android.support.v8.renderscript.*; //这句很重要啊，v8包的，不然不能向下兼容啊。public class RenderScriptGaussianBlur &#123; private RenderScript rs; public RenderScriptGaussianBlur(Context context) &#123; // 创建RenderScript内核对象 this.rs = RenderScript.create(context); &#125; /** * 将图片高斯模糊化 * @param radius 模糊半径，由于性能限制，这个值的取值区间为(0,25f] * @param bitmapOriginal 源Bitmap */ public Bitmap blur(float radius, Bitmap bitmapOriginal) &#123; Bitmap bmp = Bitmap.createBitmap(bitmapOriginal); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间。 final Allocation input = Allocation.createFromBitmap(rs, bmp); //Type: “一个Type描述了一个Allocation或者并行操作的Element和dimensions ” Type type = input.getType(); final Allocation output = Allocation.createTyped(rs, type); //创建一个模糊效果的RenderScript的工具对象 //第二个参数Element相当于一种像素处理的算法，高斯模糊的话用这个就好 final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); //设置渲染的模糊程度, 25f是最大模糊度 script.setRadius(radius); // 设置blurScript对象的输入内存 script.setInput(input); // 将输出数据保存到输出刚刚创建的输出内存中 script.forEach(output); // 将数据填充到bitmap中 output.copyTo(bmp); //销毁它们释放内存 input.destroy(); output.destroy(); script.destroy(); type.destroy(); return bmp; &#125; public void destory()&#123; this.rs.destroy(); &#125;&#125; 挺简单的几句，现在我们看看如何使用。 降低需要进行高斯模糊的图片质量虽然说使用RenderScript能够高效的进行图片的高斯模糊，但是对于较大的图片还是显的力不从心。毕竟是要对每一个像素点都要进行处理。况且一般来说，高斯模糊后图片都比较模糊，我为何要用高清图？🤣降低图片质量的代码相信大家都倒背如流了，这里就不再重复放码了。 图片的高斯模糊化一定要异步进行 12345678910111213141516171819202122232425262728293031323334353637383940//处理化一个RenderScriptGaussianBlur，记得在Activity的onDestory()中调用destroy()释放内存blurRender = new RenderScriptGaussianBlur(this);//这段代码的效果就是每点击一次按钮，高斯模糊半径blurRadius就+1，//然后在RxJava的Schedulers.computation()线程中进行Bitmap的高斯模糊化，//接着在onNext()中将处理后获得的图片设置显示。//也就是上图的效果btn2.setOnClickListener(v -&gt; &#123; if (mBitmap != null &amp;&amp; blurRadius &lt;= 25) &#123; Disposable d = Observable.create(new ObservableOnSubscribe&lt;Bitmap&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Bitmap&gt; e) throws Exception &#123; LogUtils.e("当前blurRadius = " + blurRadius); //对图片进行高斯模糊处理 Bitmap bitmap = blurRender.blur(blurRadius, mBitmap); blurRadius++; if (blurRadius == 25)&#123; blurRadius = 1; &#125; e.onNext(bitmap); e.onComplete(); &#125; &#125;) .subscribeOn(Schedulers.computation()) //指定运算线程 .observeOn(AndroidSchedulers.mainThread()) //切换回主线程 .subscribeWith(new DisposableObserver&lt;Bitmap&gt;() &#123; @Override public void onNext(Bitmap bitmap) &#123; iv.setImageBitmap(bitmap); //展示图片 &#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onComplete() &#123;&#125; &#125;); disposable.add(d); &#125; &#125;); 性能问题测试机：Meizu M2 Note系统：Android 5.1 上图高斯模糊时的CPU及内存变化： 从上图可以看到，即使我原本在播放一个动画时的CPU使用率大概在6% 左右。在开始高斯模糊运算后，随着高斯模糊半径的逐渐增大，CPU峰值最大也就在21.3%。可见这种解决方案的效率是极高的。 总结通过本篇的介绍，相信大家已经对这种在Android设备上实现高斯模糊效果的解决方案有所了解了。是不是手痒想亲自动手试一试呢？当然啦，如果产品说要个高斯模糊的效果，还是那句话：IOS专利！Android做不了！🤣 参考文献 Google Api文档 Google Blog-RenderScript in the Android Support Library Android : Simple and fast image processing with RenderScript Android RenderScript 简单高效实现图片的高斯模糊效果;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo + Github搭建自己的私人博客]]></title>
      <url>%2F2016%2F09%2F17%2F%E5%85%B6%E5%AE%83%2F%E4%BD%BF%E7%94%A8Hexo%20%2B%20Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[背景介绍 也许你已经在CSDN、简书等博客网站上创建了自己的博客。但作为程序猿，总想能够拥有一个属于自己的，能够自由DIY的私人博客。本篇文章，我将详细讲解如何搭建起一个私人博客。 动手搭建自己的私人博客吧！ 先上一张效果图: CoorChice的Blog 看起来还不错吧，简约而专注于写作。我们来看看如何实现吧。 准备阶段首先，我们需要现安装一些东西。 HomebrewHomebrew官网 Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebre可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 我们只需要打开终端，输入以下命令，确定执行后就可以安装Homebrew 了。 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 为什么需要安装Homebrew？是为了接下来方便的安装Node.js 😉 Node.js由于我们使用Hexo框架来搭建生成博客，而Hexoshi是基于Node.js的。所以，还需要安装Node.js。安装Node.js只需要在终端中输入： 1brew install node 安装完成后，输入： 1node -v 显示版本号表示已经安装完成，如下： 12MacBook-Pro:~ ******$ node -vv7.4.0 Node.js中有一个叫做npm(Node Package Manager)的工具，用于搜索、下载、管理Node的相关套件。有了这个东西，我们就能够方便的安装Hexo了。 HexoHexo官网 终于到主角儿出场了。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo也十分简单。在终端输入以下命令即可： 1sudo npm install -g hexo-cli 安装完成后，输入hexo -version 如果输出以下类似信息表示安装完成。 1234567891011121314hexo-cli: 1.0.2os: Darwin 16.3.0 darwin x64http_parser: 2.7.0node: 7.4.0v8: 5.4.500.45uv: 1.10.1zlib: 1.2.8ares: 1.10.1-DEVmodules: 51openssl: 1.0.2jicu: 58.2unicode: 9.0cldr: 30.0.3tz: 2016j hexo-deployer-git自动部署发布工具这个工具能够帮助我们快速部署博客bing并发布，安装它只需要在终端输入：1npm install hexo-deployer-git --save Github仓库我们需要到自己的Github中创建一个仓库(还不会使用Github的同学百度、Google 😒)，注意名字一定要是这种格式： 1你的Github账号的注册名称.github.io 比如我的博客地址：https://chenbingx.github.io/ 这个名称将成为以后你的博客地址。谨慎啊！ 配置博客到此我们已经准备好了搭建博客的所有原材料，下面我们真的要开始搭建了啊😉 创建本地博客仓库使用命令: 1hexo init 你的Github账号的注册名称.github.io 然后会在用户目录下生成一个名为 “你的Github账号的注册名称.github.io” 的文件夹，这个目录就是我们的博客目录。 设置主题 首先，我们一路cd到刚刚创建的目录下。先下载一个主题，这是一个示例，都是一个套路。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 这里我使用的是NexT这个主题，文档十分详细👍。NexT官网 然后我们在“你的Github账号的注册名称.github.io”目录下找到_config.yml文件，打开它(我是用Sublim Text打开的)。command + F搜索到theme:，在后面加上next，这是我们刚刚存放NexT主题的文件夹名称。 接着需要把这个博客和刚刚创建的Github仓库关联。command + F搜索deploy: 然后按照以下格式设置： 1234deploy: type: git //我们使用Git管理 repo: git@github.com:****/****.github.io.git //刚刚创建的Github仓库的SSH类型地址，使用HTTPS很有可能遇到权限问题 branch: master //你所期望的分支名称 注意，以上操作中，:号后面的空格一定不能省略。其他详细配置可以参考Hexo 的官网。 写文章我们的文章存放在博客根目录下的source/_posts文件夹下。我们可以在这个文件下建立子文件夹管理文章分类。文章类型被要求必须是.md格式的，就是Markdown。这里写Markdown与平时稍有不同，需要在头部添加： 123456---文章配置信息。这里的配置信息与我们所使用的主题有关。---从这里开始写正文内容... 发布博客注意，以下操作需要cd到博客目录下。 1234567hexo clean //每次有大变动，比如更换主题等操作时，可以清理以下之前的缓存； hexo g //即hexo generate，生成静态文件；hexo s //即hexo server，启动服务器。默认情况下，访问网址为： http://localhost:4000/； hexo d //即hexo deploy，部署网站到Github。 总结终于，我们的博客搭建完成了。我们不需要租用服务器就搭建了一个属于自己的博客，并且在Hexo框架的支持下，我们可以使用不同的主题来装饰自己的Blog。 参考文献 Homebrew官网 NexT官网 Hexo官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XML中的Bitmap]]></title>
      <url>%2F2016%2F08%2F22%2FAndroid%E7%BB%98%E5%9B%BE%2FXML%E4%B8%AD%E7%9A%84Bitmap%2F</url>
      <content type="text"><![CDATA[在xml中的drawable/目录下可以创建Bitmap资源，这样可以将一张图片直接转换成bitmap，并给它设置一些属性，它指向一个BitmapDrawable对象。 调用方法在xml中：12345格式: @[package:]drawable/filename&lt;ImageView android:layout_height="wrap_content" android:layout_width="wrap_content" android:src="@drawable/bitmap"/&gt; 在Java中：123格式：R.drawable.filenameResources res =getResources();Drawable drawable = res.getDrawable(R.drawable.bitmap); 语法123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:antialias=["true" | "false"] android:dither=["true" | "false"] android:filter=["true" | "false"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:mipMap=["true" | "false"] android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&gt; 常用的9个属性： 属性 作用 src 在这里引用图片资源 antialias 开启或关闭抗锯齿 dither 开启或关闭图像抖动。当使用图片的dpi和屏幕不匹配时，开启图像抖动可以获得更好的显示效果 filter 开启或关闭滤镜。当需要对图片进行缩放操作时，开启滤镜可以使图片更加平滑 tiltMode 贴图模式。详细见下文。该属性与gravity是互斥的。 gravity 重心。详细见下文。该属性与tileMode是互斥的。 tint 设置着色。有种盖一个色层在图片上的感觉。 tintMode 设置着色模式。详细见下文。 mipMap 是否将图片标记为mipmap，使用mipmap能够提高显示性能，默认为false android:tileMode属性贴图模式有以下几种： 值 效果 clamp 当图片&gt;容器时，图片多余的部分会被截去；当图片&lt;容器时，会复制图片的边缘部分填充空白 disable 图片会根据容器大小进行缩放。这是默认值 repeat 图片会重复填充满容器。但是当图片&gt;容器时，多余部分会被截去 mirror 图片会以镜像重复的形式填满容器。同样，当图片&gt;容器时，多余部分会被截去 android:gravity属性当图片&lt;容器时，重心决定了它在容器中的位置。重心有以下几种： 值 效果 top 顶部 bottom 底部 left 左边 right 右边 center 中心 center_vertical 垂直中心 center_horizontal 水平中心 fill 充满容器，和tileMode=”disable”是一个效果 fill_vertical 充满垂直方向 fill_horizontal 充满水平方向 clip_vertical 搞不懂是什么鬼？求大神解答 clip_horizontal 搞不懂是什么鬼？求大神解答 android:tintMode属性着色模式有以下几种： 值 效果 add src_in src_over src_atop 以上几种全把图片给遮住了，看不出有什么差别。求指导！ mutiply 着色与透明度相结合，相当于在图片上盖了一层不是很深的颜色 screen 同上，但是颜色会更浅 一个例子1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:alpha="1" android:antialias="true" android:dither="true" android:filter="true" android:gravity="clip_vertical" android:src="@drawable/share" android:tint="#fc747e" android:tintMode="multiply" /&gt; 效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android本地化全局对象的实践——SharePreferences]]></title>
      <url>%2F2016%2F08%2F21%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FAndroid%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94SharePreferences%2F</url>
      <content type="text"><![CDATA[上一篇讲到了使用File的方式来本地化全局对象，它适合体量较大的全局对象。对于一些体量较小的全局，并且对安全性有要求的对象，可以使用SharePreference来进行对像的本地化。注意，这种方式适合较小的对象，较大的对象还是应该选用File的方式。 使用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//全局对象和上一篇中一样public class User implements Serializable, Cloneable &#123; public static final long serialVersionUID = 1L; private int userId; private String userNikeName; private String userRealName; private int userLevel; private int vipLevel; public User() &#123; &#125; public User(int userId, String userNikeName, String userRealName, int userLevel, int vipLevel) &#123; this.userId = userId; this.userNikeName = userNikeName; this.userRealName = userRealName; this.userLevel = userLevel; this.vipLevel = vipLevel; &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getUserNikeName() &#123; return userNikeName; &#125; public void setUserNikeName(String userNikeName) &#123; this.userNikeName = userNikeName; &#125; public String getUserRealName() &#123; return userRealName; &#125; public void setUserRealName(String userRealName) &#123; this.userRealName = userRealName; &#125; public int getUserLevel() &#123; return userLevel; &#125; public void setUserLevel(int userLevel) &#123; this.userLevel = userLevel; &#125; public int getVipLevel() &#123; return vipLevel; &#125; public void setVipLevel(int vipLevel) &#123; this.vipLevel = vipLevel; &#125; protected User(Parcel in) &#123; this.userId = in.readInt(); this.userNikeName = in.readString(); this.userRealName = in.readString(); this.userLevel = in.readInt(); this.vipLevel = in.readInt(); &#125;&#125;//下面两个方法实现了Object对象和编码方式为Base64的字符串的互相转换public static final String ObjectToBase64String(Object object) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); String base64String = Base64.encodeToString(baos.toByteArray(), Base64.DEFAULT); //采用Base64编码方式编码对象生成的字节数组为字符串 if (oos != null)&#123; oos.close(); &#125; if (baos != null)&#123; baos.close(); &#125; return base64String; &#125; public static final &lt;T&gt; T Base64StringToObject(String base64String, Class&lt;T&gt; clazz) throws IOException, ClassNotFoundException &#123; byte[] bytes = Base64.decode(base64String, Base64.DEFAULT); //解码 ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); T t = (T) ois.readObject(); if (ois != null) &#123; ois.close(); &#125; if (bais != null) &#123; bais.close(); &#125; return t; &#125; //下面两个方法是进行存取的public class SharePreferencesUtils &#123; public static final void saveObject(@NonNull Context context, String key, @NonNull Object object) throws IOException &#123; SharedPreferences sp = context.getSharedPreferences(key, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); String base64String = AppUtils.ObjectToBase64String(object); editor.putString(key, base64String); editor.commit(); &#125; public static final &lt;T&gt; T restoreObject(@NonNull Context context, String key, Class&lt;T&gt; clazz) throws IOException, ClassNotFoundException &#123; SharedPreferences sp = context.getSharedPreferences(key, Context.MODE_PRIVATE); String base64String = sp.getString(key, ""); T t = null; if (!base64String.equals(""))&#123; t = AppUtils.Base64StringToObject(base64String, clazz); &#125; return t; &#125;&#125;//现在就可以开始使用啦private void saveUserToSP(User user)&#123; try &#123; SharePreferencesUtils.saveObject(this, AppConstant.USER_KEY,user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private User restoreUserFromSP()&#123; User user = null; try &#123; user = SharePreferencesUtils.restoreObject(this,AppConstant.USER_KEY,User.class); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return user; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android本地化全局对象的实践——File]]></title>
      <url>%2F2016%2F08%2F21%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FAndroid%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94File%2F</url>
      <content type="text"><![CDATA[本地化全局变量在开发中，我们经常遇到一些对象是需要供全局使用的，当这样的对象比较复杂时，将它本地化是非常必要的。这样不仅能够避免频繁的创建这些复杂的对象，还能保存住对象的状态。下面先是一种本地化全局对象的解决方案，主要使用File实现。注意：这个方法在进行大量复杂数据的存取过程中，可能造成ANR，因为作为全局变量，我们需要频繁的修改和读取它。 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//全局对象类//需要实现Serializable接口，保证对象可序列化。//实现Cloneable接口，使对象可以被clone。public class User implements Serializable, Cloneable &#123; //serialVersionUID是Serializable的一个特性变量，它是对象序列化的一个标识，通过这个标识检查，对象才能够被正确的反序列化。 //这里我们把它的serialVersionUID固定，保证下次从本地文件读取时能够正确的序列化。如果不指定，Java会每次随机生成，当我们试图去读取时，就会获得失败。 public static final long serialVersionUID = 1L; private int userId; private String userNikeName; private String userRealName; private int userLevel; private int vipLevel; public User() &#123; &#125; public User(int userId, String userNikeName, String userRealName, int userLevel, int vipLevel) &#123; this.userId = userId; this.userNikeName = userNikeName; this.userRealName = userRealName; this.userLevel = userLevel; this.vipLevel = vipLevel; &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getUserNikeName() &#123; return userNikeName; &#125; public void setUserNikeName(String userNikeName) &#123; this.userNikeName = userNikeName; &#125; public String getUserRealName() &#123; return userRealName; &#125; public void setUserRealName(String userRealName) &#123; this.userRealName = userRealName; &#125; public int getUserLevel() &#123; return userLevel; &#125; public void setUserLevel(int userLevel) &#123; this.userLevel = userLevel; &#125; public int getVipLevel() &#123; return vipLevel; &#125; public void setVipLevel(int vipLevel) &#123; this.vipLevel = vipLevel; &#125; protected User(Parcel in) &#123; this.userId = in.readInt(); this.userNikeName = in.readString(); this.userRealName = in.readString(); this.userLevel = in.readInt(); this.vipLevel = in.readInt(); &#125;&#125;//把对象本地保存 public static final void saveObject(String path, Object object) &#123; FileOutputStream fos = null; ObjectOutputStream oos = null; File file = new File(path); try &#123; LogUtils.e(file.getAbsolutePath()); fos = new FileOutputStream(file); oos = new ObjectOutputStream(fos); oos.writeObject(object); //写入对象 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (oos != null) &#123; oos.close(); &#125; if (fos != null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //从本地读取对象的方法public static final Object restoreObject(String path) throws FileNotFoundException &#123; FileInputStream fis = null; ObjectInputStream ois = null; Object object = null; File file = new File(path); if (!file.exists())&#123; throw new FileNotFoundException("请求文件不存在，请检查路径是否正确。"); &#125; try &#123; LogUtils.e(file.getAbsolutePath()); fis = new FileInputStream(file); ois = new ObjectInputStream(fis); object = ois.readObject(); //读取对象 &#125; catch (ClassNotFoundException | IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (ois != null) &#123; ois.close(); &#125; if (fis != null) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return object; &#125; &#125; //使用//在每次修改对象的时候都需要调用保存去覆盖保存本地的对象文件。private void saveUser(@NonNull User user) &#123; //最后的.xxx是可以随便指定的，比如我们也可以使用.txt String savePath = FileUtils.getAppObjectDir() + "user" + user.getUserId() + ".obj"; FileUtils.saveObject(savePath, user); &#125; private User restoreUser() &#123; User restoreUser = null; String path = FileUtils.getAppObjectDir() + "user" + 1000000 + ".obj"; try &#123; restoreUser = (User) FileUtils.restoreObject(path); &#125; catch (FileNotFoundException | NullPointerException e) &#123; e.printStackTrace(); &#125; return restoreUser; &#125; //最后不要忘记在AndroidMainfest.xml中添加权限&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Reflect反射简略教程]]></title>
      <url>%2F2016%2F08%2F20%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FReflect%E5%8F%8D%E5%B0%84%E7%AE%80%E7%95%A5%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[简单介绍java的反射机制使java成为一种动态语言，通过反射机制能够在运行时或的一个对象的所有信息，包括他的包名，它的所有方法和成员变量。当然知道包名可以直接取得该类，从而获得他的实例。 获取Class对象12345678//通过对象获得：class = b.getClass();//通过完整包类名获得：class = Class.fromName("包名.类名")//本包可以通过.class获得：class = 类名.class 通过反射调用私有方法123456789101112131415161718192021//获得类Class&lt;?&gt; c1 = persen.getClass();try &#123; //通过方法名获得方法，这是私有方法 Method method1 = c1.getDeclaredMethod("method1"); //调用方法私有方法的关键 method1.setAccessible(true); //设置该私有方法可被调用 //方法调用 method1.invoke(c1.newInstance()); //这是带参数的方法，需要在获得方法的时候把参数的类型都加上 Method method2 = c1.getDeclaredMethod("method2",String.class); //调用方法，填写参数 method2.invoke(c1.newInstance(),"kk"); //这是有返回值的方法 Method method3 = c1.getDeclaredMethod("method3"); return (int) method3.invoke(c1.newInstance());&#125; catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace();&#125; 通过反射操作私有属性123456789101112131415Class c1 = persen.getClass();try &#123; //通过属性名获得属性 Field name = c1.getDeclaredField("name"); //由于是私有属性，所以需要设置它可见 name.setAccessible(true); //直接修改该对象的该属性的值 name.set(persen,"小明"); //获得该对象的该属性的值 return (String) name.get(persen);&#125; catch (NoSuchFieldException e) &#123; e.printStackTrace();&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; 奉上一个调用反射的帮助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static Method getMethod(@NonNull Class&lt;?&gt; clazz, @NonNull String methodName) throws NoSuchMethodException &#123; Method method = clazz.getDeclaredMethod(methodName); method.setAccessible(true); return method; &#125; public static Method getMethod(@NonNull Class&lt;?&gt; clazz, @NonNull String methodName, Class... parameterTypes) throws NoSuchMethodException &#123; Method method = clazz.getDeclaredMethod(methodName, parameterTypes); method.setAccessible(true); return method; &#125; public static Method getApiMethod(@NonNull Class&lt;?&gt; clazz, @NonNull String methodName) throws NoSuchMethodException &#123; Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) &#123; if (method.getName().contains(methodName)) &#123; method.setAccessible(true); return method; &#125; &#125; return null; &#125; public static void invokeMethod(@NonNull Class&lt;?&gt; clazz, @NonNull String methodName) throws IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; getMethod(clazz, methodName).invoke(clazz.newInstance()); &#125; public static &lt;T&gt; void invokeMethod(T t, @NonNull String methodName) throws IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; getMethod(t.getClass(), methodName).invoke(t); &#125; public static &lt;T, V&gt; void invokeApiMethod(T t, @NonNull String methodName, V v, Class... parameterTypes) throws IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; getApiMethod(t.getClass(), methodName).invoke(t, v); &#125; public static Field getVariable(@NonNull Class&lt;?&gt; clazz, @NonNull String variableName) throws NoSuchFieldException &#123; Field variable = clazz.getDeclaredField(variableName); variable.setAccessible(true); return variable; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dagger2简略教程]]></title>
      <url>%2F2016%2F08%2F19%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FDagger2%E7%AE%80%E7%95%A5%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[什么是注解依赖 依赖：当A类中有B类的实例时（或者A类需要用到B类的一些特性），就称B类为A类的依赖。 注解：无需new就能把B类的一个实例添加到A类中的操作。Dagger2简介Dagger2是由Google接手Dagger1开发的一个注解框架，它的主要特性就是利用有向无环（这种结构意味着在你设计注解框架的时候，不能形成循环）这样一种结构来描述类间的关系，从而达到一种“描述创建”的效果。比如：现在需要一台 咖啡机 ，可以通过事先描述好其如何制造（相当于描述了一个蓝图），然后你就只需要说（即使用 @Inject 注解符）来一台咖啡机，Dagger就会制造一台在你指定的地方。注解符@Inject 用于告诉Dagger，你现在需要注入一个实例到这个地方。 123456public class CoffeMaker｛ @Inject CoffeMachine coffeMachine; /*Dagger会自动识别本次需求，并开始匹配CoffeMachine 的制造说明，制造一台CoffeMachine放倒该类中。 */ 使用@Inject注解构造器，可以告诉Dagger，该构造器当有地方需要注入实例时，可以使用这个构造器来创建实例。 1234567public class CoffeMachine&#123; //现在Dagger已经知道了这个构造器的存在，在需要时将被调用。 @Inject public CoffeMachine()&#123; initCoffeMachine(); &#125;&#125; @Module用于标识一个模型类，实例的创建描述需要放到这个类中，并且每一个创建规则都需要用 @Provides 来标注，这样Dagger才能在需要调用的时候去匹配它。123456789101112131415@Modulepublic class CoffeMachineModule｛ private CoffeMachine mCoffeMachine; public CoffeMachineModule(CoffeMachine coffeMachine)｛ mCoffeMachine = coffeMachine &#125; /** * 当有地方调用了@Inject CoffeMachine coffeMachine * 之后，Dagger就会匹配该方法来提供一个实例给调用者。 */ @Provides CoffeMachine providesCoffeMachine()&#123; return mCoffeMachine; &#125; @Provides必须放在@Module类中，或者说有这个注解符的类都需要使用@Module注解。这里需要注意的是，@Provides注解的方法中如果有参数的话，那么这个参数也必须由一个@Provides所注解的方法提供。它相当于标注了一个实例提供者。123456789101112/*这个实例提供者需要一个Heater参数，这个参数又需要下面的 Heater实例提供者来提供。以此类推。*/@ProvidesCoffeMachine2 providesCoffeMachine2(Heater heater)&#123; return new CoffeMachine2(heater);&#125;@ProvidesHeater provideHeater()&#123; return new Heater();&#125; @Component这是个组件使@Inject与@Module产生关联的接口类，并且Dagger会根据这个类自动生成一个有名为Dagger + 该接口类类名 的类，这个类采用的是构造器（Builder）模式。在这个接口中，可以指明需要注解的地方，或者暴露一些所需的实例。1234567@Component(module = &#123;CoffeMachine.class&#125;)public interface CoffeMakerComponent&#123; //这个方法指明需要注解的地方 TagerActivity inject(TagerActivity tagerActivity); Suger getSuger();&#125; @Singleton被标注的类将只存在一个实例。 12345678910111213//加了@Singleton之后提示这个接口将被多个线程共同操作。@Singleton@Component(module = &#123;CoffeMachine.class&#125;)public interface CoffeMakerComponent&#123; //这个方法指明需要注解的地方 TagerActivity inject(TagerActivity tagerActivity); Suger getSuger();&#125;//@Singleton标注后将只会产生一个Heater实例@Provides @Singleton Heater provideHeater()&#123; return new Heater()&#125; @Scope自定义注解符，可以注解一个自定义的注解符来描述一个作用范围。 12345678//下面注解了一个新的注解符——@PerActibity，使用这个注解符的地方作用范围将被限制在Activity的生命周期内。@Scope@Retention(RUNTIME)public @interface PerActivity()&#123;&#125;//下面注解了一个新的注解符——@PerFragemnt，使用这个注解符的地方作用范围将被限制在Fragment的生命周期内。@Scope@Retention(RUNTIME)public @interface PerFragment()&#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava简略教程]]></title>
      <url>%2F2016%2F08%2F18%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FRxJava%E7%AE%80%E7%95%A5%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[中文官方文档 教程 一、为什么要使用响应式编程1.尽管响应式编程代码量比普通线程处理方式代码量大，但是响应式的突出特点就是更符合人的逻辑思维，更容易被理解。2.响应式编程目的是为了处理线程工作的，它有一个观察者（Observer）在随时待命，准备接收可观察对象（Observable）发送的数据。3.响应式编程的代码能够按照顺序一步步执行。 二、预备概念1.Subscriber订阅者（本质上也是一个观察者），它可以订阅一个可观察对象Observable，通常这个可观察对 象可能会是一个异步任务。2.Observable可观察对象，一个异步任务可作为一个可观察对象。可观察对象分为热和冷： 热的可观察对象一创建就能够发射数据，因此订阅它的观察者Observer可能就会因为创建的比较晚而错过一些数据。 冷的可观察对象需要等到有一个观察者观察它时，它才开始发射数据。 还有一种比较特 DZ殊的Observable是connectable类型的，它只有在connect()方法被调用之后才会开 始发射数据。3.Subject这是一个十分特殊的类型，它相当于一个桥梁。可以说，它既是一个Observer，又是一个Observable。4.Scheculer调度器，用于指定工作线程。SubscribeOn()用于指定可观察者的逻辑线程，ObserveOn()用于指定订阅者的逻辑线程。 当二者都没指定时，在当前线程中工作。 当只指定了SubscribeOn()，那么就都在这个线程中工作。 当指定了ObserveOn()，那么可观察者运行在默认线程，而订阅者运行在指定线程。操作符一、创建操作符 create：从头开始创建可观察对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Log.e("MainActivity", " -&gt; initData: " + Thread.currentThread().getName()); //使用Create操作符创建可观察者 Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; //发射前的逻辑处理 @Override public void call(Subscriber&lt;? super Integer&gt; observer) &#123; try &#123; if (!observer.isUnsubscribed()) &#123; for (int i = 1; i &lt; 3; i++) &#123; observer.onNext(i); Thread.sleep(1000); Log.e("MainActivity", " -&gt; call: " + Thread.currentThread().getName()); &#125; observer.onCompleted(); &#125; &#125; catch (Exception e) &#123; observer.onError(e); &#125; &#125; &#125; ) //指定可观察者的逻辑线程 //.subscribeOn(Schedulers.newThread()) //指定订阅者的逻辑线程,没有指定则与subscribeOn()在同一个线程工作。如果两者都没指定,就在当前线程中工作。 .observeOn(Schedulers.io()) //可观察者发射数据 .subscribe( //创建订阅者 new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer item) &#123; System.out.println("Next: " + item); Log.e("MainActivity", " -&gt; onNext: " + Thread.currentThread().getName()); &#125; @Override public void onError(Throwable error) &#123; System.err.println("Error: " + error.getMessage()); &#125; @Override public void onCompleted() &#123; System.out.println("Sequence complete."); &#125; &#125;); from：通过一个集合创建可观察对象。 123456789101112131415161718192021222324List&lt;String&gt; data = new ArrayList&lt;&gt;(); data.add("1"); data.add("2"); data.add("3"); // 把一个集合转化为数据按顺序发射 Observable.from(data) // 指定可观察者工作线程 .subscribeOn(Schedulers.newThread()) // 指定订阅者工作线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe( s -&gt; &#123; Log.e("MainActivity", " -&gt;Action1 call: " + s); Log.e("MainActivity", " -&gt; Action1 call: thread" + Thread.currentThread()); &#125;, throwable -&gt; &#123; Log.e("MainActivity", " -&gt;Action1-Throwable call: " + throwable); Log.e("MainActivity", " -&gt; Action1-Throwable call: thread" + Thread.currentThread()); &#125;, () -&gt; &#123; Log.e("MainActivity", " -&gt;Action0 call: "); Log.e("MainActivity", " -&gt; Action0 call: thread" + Thread.currentThread()); &#125;); just：同from类似，只是just的值是在()中指定的。 123456789101112131415161718192021222324252627282930313233 Observable.just(1, "3", true) // 按顺序发送三种不同类型的数据 // 订阅者的工作线程 .observeOn(Schedulers.newThread()) // 订阅 .subscribe( // 创建订阅者,范型是个可序列化对象。 new Subscriber&lt;Serializable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Serializable serializable) &#123; if (serializable.equals(1)) &#123; Log.e("MainActivity", " -&gt; onNext: int = " + serializable.toString()); &#125; if (serializable.equals("3")) &#123; Log.e("MainActivity", " -&gt; onNext: String = " + serializable.toString()); &#125; if (serializable.equals(false)) &#123; Log.e("MainActivity", " -&gt; onNext: boolean = " + true); &#125; &#125; &#125;);输出结果：MainActivity: -&gt; onNext: int = 1MainActivity: -&gt; onNext: String = 3 timer：在指定时间之后创建一个发射0的可观察者。 123456789101112131415161718192021Observable.timer(2, TimeUnit.SECONDS) //通过timer创建延迟2s发射的可观察者,它会发射一个0 //指定订阅者的工作线程 .subscribeOn(Schedulers.newThread()) //订阅,并创建订阅者 .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.e("MainActivity", " -&gt; onNext: along = " + aLong); &#125; &#125;); 变换操作符变换操作符可以在发射过程中对发送的数据进行加工。 map：可在Observable发射前对初始的数据进行一次变换，通过Func1接口来进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Observable.just( "http://img.pconline.com.cn/images/upload/upc/tx/photoblog/1503/17/c2/3974265_1426551589288_mthumb.jpg") .map(s -&gt; &#123; // 在这里使用map操作符,把String类型的数据转换成了Bitmap类型,继续往下传递 try &#123; // 下载图片 URL url = new URL(s); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setDoInput(true); conn.setConnectTimeout(5000); conn.connect(); if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStream is = conn.getInputStream(); byte[] bytes = new byte[1024]; ByteArrayOutputStream byteBuffer = new ByteArrayOutputStream(); int length = 0; while ((length = is.read(bytes)) != -1) &#123; byteBuffer.write(bytes, 0, length); byteBuffer.flush(); &#125; byte[] bmpBytes = byteBuffer.toByteArray(); Log.e("MainActivity", " -&gt; initData: byte.size = " + bmpBytes.length); return BitmapFactory.decodeByteArray(bmpBytes, 0, bmpBytes.length); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;) .map(BitmapDrawable::new) // 这里再一次把Bitmap类型的数据转换成了Drawable往下传递 .subscribeOn(Schedulers.io()) // 指定可观察者工作线程 .observeOn(AndroidSchedulers.mainThread()) // 指定订阅者的工作线程 // 订阅 .subscribe( // 创建订阅者 new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Drawable drawable) &#123; displayImage.setImageDrawable(drawable); &#125; &#125;); flatMap：功能与map类似，但它返回的是一个Observable&lt;转化类型&gt;。1234567891011121314151617181920212223242526272829APIClient.getArticles() // 在调用OnNext()之前先调用这个方法,这里的OnNext()是由Retrofit去调用的。 .doOnNext(articles -&gt; &#123; Log.e("MainActivity", " -&gt; initData: itemsSize = " + articles.items.size()); articles.items.remove(0); &#125;) // 用上一个Observable返回的结果来创建一个新的Observable .flatMap(articles -&gt; Observable.from(articles.items)) // 这里使用了from方法创建Observable // 指定接收者的工作线程 .observeOn(AndroidSchedulers.mainThread()) // 发射给订阅者 .subscribe( // 创建订阅者 new Subscriber&lt;Articles.ItemsTestBean&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Articles.ItemsTestBean itemsTestBean) &#123; Log.e("MainActivity", " -&gt; onNext: item " + i++ + " = " + itemsTestBean.id); &#125; &#125;); 过滤操作符 filter：通过Func1接口来实现过滤掉数据源中不符合条件的数据。 1234567891011121314151617181920212223Observable.just(1,2,3,4,5) //过滤出小于4的数据，并且发射它们 .filter(new Func1&lt;Integer,Boolean&gt;() &#123; @Override public Boolean call(Integer item)&#123; retrun (item&lt;4); &#125; &#125;).subscribe(new Subscriber&lt;Integer&gt; ()&#123; @Override public void onNext(Integer item) &#123; System.out.println("Next: " + item); &#125; @Override public void onError(Throwable error) &#123; System.err.println("Error: " + error.getMessage()); &#125; @Override public void onCompleted() &#123; System.out.println("Sequence complete."); &#125; &#125;)； first：只发射第一条数据，或者过滤出来的第一条数据。 1234567891011121314151617181920212223Observable.just(1,2,3,4,5) //过滤出大于4的数据，并且发射只发射第一个数据 .first(new Func1&lt;Integer,Boolean&gt;() &#123; @Override public Boolean call(Integer item)&#123; retrun (item&gt;4); &#125; &#125;).subscribe(new Subscriber&lt;Integer&gt; ()&#123; @Override public void onNext(Integer item) &#123; System.out.println("Next: " + item); &#125; @Override public void onError(Throwable error) &#123; System.err.println("Error: " + error.getMessage()); &#125; @Override public void onCompleted() &#123; System.out.println("Sequence complete."); &#125; &#125;)； take：只发射前几条数据。 12345678910111213141516171819Observable.just(1,2,3,4,5) //只发射前3个数据 .take(3) .subscribe(new Subscriber&lt;Integer&gt; ()&#123; @Override public void onNext(Integer item) &#123; System.out.println("Next: " + item); &#125; @Override public void onError(Throwable error) &#123; System.err.println("Error: " + error.getMessage()); &#125; @Override public void onCompleted() &#123; System.out.println("Sequence complete."); &#125; &#125;)；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android只需两步，使你的Android Studio支持Lambda表达式]]></title>
      <url>%2F2016%2F08%2F17%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FAndroid%E5%8F%AA%E9%9C%80%E4%B8%A4%E6%AD%A5%EF%BC%8C%E4%BD%BF%E4%BD%A0%E7%9A%84Android%20Studio%E6%94%AF%E6%8C%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Java8的一大新特性就是较为健全的Lambda表达式，但是目前Android studio并不支持这一特性。但是可以通过在gradle中配置几行代码，引用Github上的资源，就可以让你的Android Studio支持Lambda表达式了。 注意：使用Lambda之前，必需确保你的Java8是能够运行的。下面直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354apply plugin: 'com.android.application'android &#123; compileSdkVersion 23buildToolsVersion "23.0.2"//需要添加的第一部分：//下面这两句在创建项目时不会自动生成，必需加上，是为了引用Java8的。compileOptions &#123;sourceCompatibility JavaVersion.VERSION_1_8targetCompatibility JavaVersion.VERSION_1_8&#125; defaultConfig &#123;applicationId "*************"minSdkVersion 21targetSdkVersion 23versionCode 1versionName "1.0"&#125; buildTypes &#123; release &#123;minifyEnabled falseproguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12'compile 'com.android.support:appcompat-v7:23.1.1'&#125;//需要添加的第二部分：//以下全部都是要添加到项目的build.gradle中的。//注意，经测试，只有3.2.4能够生效，如果有更新还请能够留言通知。buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'me.tatarka:gradle-retrolambda:3.2.4'&#125;&#125;repositories &#123; mavenCentral()&#125;apply plugin: 'me.tatarka.retrolambda' 只用添加标注的两部分即可，其余部分不用管。 来张效果图： 在代码中使用Lambda表达式可以使你的代码更加简洁清晰，提高效率和可读性。 Android Studio 2.1 之后开启LambdaAndroidStudio2.1之后，Google引入了新的编译器Jack，将来可能是要替换掉现在的编译器的。它编译生成的文件类型与现有的Java编译器是不同的，但据说它能最大限度地缩小APK的体积，提高编译效率，并且64K这种蛋碎的问题也将不再存在了。 说了这么多其实只是想说，现在你只需要在 gradle中把它开启就行了：123defualtConfig&#123;trueuseJack(true)&#125; 下面这一段仍然是需要添加的，只有这样才能启用Java81234compileOptions &#123;truesourceCompatibility JavaVersion.VERSION_1_8truetargetCompatibility JavaVersion.VERSION_1_8&#125; 温馨提示：目前Jack还不完善，实际开发过程中可能会遇到一些诡异的坑，这将导致你不得不把他关闭。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android多渠道打包——使用Python脚本秒打]]></title>
      <url>%2F2016%2F08%2F16%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FAndroid%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%A7%92%E6%89%93%2F</url>
      <content type="text"><![CDATA[前言我们的应用通常会通过许多渠道发布到各个平台上，而我们需要追踪各个平台的下载信息，所以需要针对不同的平台打相应的包。但是平台众多，有的应用可能需要发布到几十的渠道上，使用传统的gradle脚本自动打包可能需要花费几个小时的时间。而改方法可以实现秒打100个各个渠道包的效果。这里我以使用最多的友盟统计SDK为例来讲解。 需要准备的文件 一个空的channel.apk(可以通过改.txt为.apk实现) 一个不包含渠道信息的公开版apk文件，我命名为”sourec.apk“ 一个配置有渠道信息的channel.txt文件 重点：一个配置好的python脚本，我命名为batch_apk.py注意：这四个文件需要放到一个文件夹下。创建4个必要文件生成sourec.apk按照生成公版包的方法生成apk就行了，注意不能包含渠道信息，即把producteFlavors{}去掉。特别说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//通常我们会在AndroidManifest.xml中配置友盟的appkey和渠道信息，就像下面这样:&lt;!--友盟的key--&gt; &lt;meta-data android:name="UMENG_APPKEY" android:value="57****************"/&gt; &lt;!--友盟渠道号--&gt; &lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;UMENG_CHANNEL_VALUE&#125;"/&gt;//现在，我们需要把它全删掉，改为在Application的onCreate()中来初始化友盟的信息@Override public void onCreate() &#123; super.onCreate(); String appkey = "57****************"; String channelId = ManifestUtils.getChannel(this); //这个方法会从META_INFO文件下读取渠道标志 MobclickAgent.UMAnalyticsConfig config = new MobclickAgent.UMAnalyticsConfig(this, appkey, channelId); //初始化友盟配置信息 LogUtils.e(config.mChannelId); MobclickAgent.startWithConfigure(config); //设置友盟配置信息 &#125; //这里可能会用到一个工具类ManifestUtilspublic class ManifestUtils &#123; public static String channel; public static String getUmengChannel(Context context) &#123; // return getMetaDataFromApplication(context, "UMENG_CHANNEL"); return getChannel(context); &#125; /** * 获取META-INFO下面的渠道 * @param context * @return */ public static String getChannel(Context context) &#123; if (!TextUtils.isEmpty(channel)) &#123; return channel; &#125; ApplicationInfo appinfo = context.getApplicationInfo(); String sourceDir = appinfo.sourceDir; ZipFile zipfile = null; final String start_flag = "META-INF/channel_"; try &#123; zipfile = new ZipFile(sourceDir); Enumeration&lt;?&gt; entries = zipfile.entries(); while (entries.hasMoreElements()) &#123; ZipEntry entry = ((ZipEntry) entries.nextElement()); String entryName = entry.getName(); if (entryName.contains(start_flag)) &#123; channel = entryName.replaceAll(start_flag, ""); return channel; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (zipfile != null) &#123; try &#123; zipfile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return ""; &#125;&#125; 生成channel.apk和channel.txtchannel.apk的生成方式前面已经介绍过了，下面就说一下channel.txt。这个文件下只需要写上我们需要发布的渠道名称就行了，其实就是一行一个渠道名称，python脚本会逐个遍历生成相应的渠道包。这是一个例子：12336091QQ 编写Python脚本在mac上不方便的，可以使用Android Studio创建一个.txt文件，然后把Python脚本编辑好，把这个文件拖出来，然后改后缀名为.py。下面是Python脚本的具体内容:1234567891011121314151617181920212223242526272829303132333435363738import sys,os,shutil,zipfile,time //导入依赖库apkVersion="1.3" //注意这里，每次需要把这个版本号改成我们所期望的srcFileName="source.apk" //读取我们打包好的apk文件destDir=os.path.abspath('.')file=open("channel.txt") //打开包含渠道名称的文件def writeChannelToApk(filename,channel): z=zipfile.ZipFile(filename,'a',zipfile.ZIP_DEFLATED) empty_channel_file="META-INF/channel_&#123;channe&#125;".format(channe=channel) target_file="channel.apk" z.write(target_file,empty_channel_file) z.close() print "writeChannelToApkchannel"+channel+","+filename+"\n"def cpFile(srcPath,fileName): destPath = destDir + os.path.sep + fileName if os.path.exists(srcPath) and not os.path.exists(destPath): shutil.copy(srcPath,destPath)def getTime(): return time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(time.time()))if not os.path.exists(srcFileName): print "sourcefile"+srcFileName+"notexists" sys.exit(1)start = time.clock()for line in file: channel=line.strip('\n').strip() targetFileName="apk_"+channel+"-"+apkVersion+"-"+getTime()+".apk" //在这里调整渠道包的名称 print "copyfile:"+targetFileName cpFile(srcFileName,targetFileName) writeChannelToApk(targetFileName,channel)end = time.clock()print("The function run time is : %.03f seconds" %(end-start)) 运行脚本打开命令行，进入到脚本所在文件加下，在终端输入:1python batch_apk.py //运行python脚本，名称自取。 仅仅一瞬间，我们会发现，在该文件夹下已经生成了我们需要的渠道包。 检验在Activity中加入如下代码，检验渠道信息是否成功包含到渠道包中：12String channelId = AnalyticsConfig.getChannel(getApplicationContext()); //获取友盟的渠道配置信息 LogUtils.e("channelId = " + channelId); 注意一些坑没安装专门的开发环境，在Mac下直接打开python文件编辑，会产生字符集不存在的错误。解决办法是在Android Studio中编辑好拖出来。或者在改动时，一些可以复制的字母和符号就直接复制过去用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android多渠道打包——使用gradle进行多渠道自动打包]]></title>
      <url>%2F2016%2F08%2F15%2FAndroid%E5%AE%9E%E7%94%A8%E4%B9%8B%E9%81%93%2FAndroid%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8gradle%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%B8%A0%E9%81%93%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[前言在我的另一篇文章中介绍了如何使用Python进行多渠道打包，下面再把传统的gradle多渠道打包方式介绍一下，同样是以友盟SDK为例。 打包前配置配置gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//主要是配置android&#123;&#125;封包下的内容android &#123; 。 。 。signingConfigs &#123; //配置签名文件，可以有多个 icekey &#123; keyAlias 'icekey' keyPassword '填入key的密码' storeFile file('/Users/**********/icekey.jks') //key所在文件夹 storePassword '填入store的密码' &#125; &#125; buildTypes &#123; //配置构建版本，可以有多个 //测试版本 debug &#123; debuggable true zipAlignEnabled false shrinkResources false signingConfig signingConfigs.icekey minifyEnabled false &#125; //发布版本 release &#123; debuggable false //是否开启测试 zipAlignEnabled true //是否启用zipAlign压缩优化 shrinkResources true //是否删除未被使用的资源文件 minifyEnabled false //是否开启混淆 signingConfig signingConfigs.icekey //签名文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //指定混淆文件 &#125; //空版本 source &#123; debuggable true //是否开启测试 zipAlignEnabled true //是否启用zipAlign压缩优化 shrinkResources true //是否删除未被使用的资源文件 minifyEnabled false //是否开启混淆 signingConfig signingConfigs.icekey //签名文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //指定混淆文件 &#125; &#125; //创建渠道名称,main&#123;&#125;是一个不合法名称 productFlavors &#123; baidu &#123;&#125; huawei &#123;&#125; xiaomi &#123;&#125; &#125; // 这里体现在AndroidManifest中的// &lt;meta-data// android:name="UMENG_CHANNEL"// android:value="$&#123;UMENG_CHANNEL_VALUE&#125;"/&gt; //运行自动赋值给AndroidManifest.xml中的$&#123;UMENG_CHANNEL_VALUE&#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125; lintOptions &#123; //配置打包线程的操作 ignoreWarnings true //忽略警告 checkReleaseBuilds false //是否检查release版本 abortOnError false //出现错误是否终止 &#125; applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(".apk")) &#123; //判断是否是apk //这个函数生成了apk的名称 def apkName = "ice-$&#123;variant.productFlavors[0].name&#125;-$&#123;defaultConfig.versionName&#125;.apk" output.outputFile = new File(outputFile.parent, apkName) //输出文件 &#125; &#125; &#125; 。 。 。&#125; 配置AndroidManifest.xml在Application标签下添加：12345678&lt;!--友盟的key--&gt; &lt;meta-data android:name="UMENG_APPKEY" android:value="57bf375ee0f5*******018a3"/&gt; &lt;!--友盟渠道号--&gt; &lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;UMENG_CHANNEL_VALUE&#125;"/&gt; //这样写就能够读取gradle中的[UMENG_CHANNEL_VALUE: name]的name的值了。 开始自动打包在Android Studio的的终端机中输入12./gradlew assembleRelease //打包所有渠道的Release版包./gradlew assembleSource //打包所有渠道的Source版包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android退出程序的两种方式：killProcess（）和System.exit()]]></title>
      <url>%2F2016%2F08%2F14%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FAndroid%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9AkillProcess%EF%BC%88%EF%BC%89%E5%92%8CSystem.exit()%2F</url>
      <content type="text"><![CDATA[KillProcess()调用1android.os.Process.killProcess(android.os.Process.myPid()) 可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）。当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因. System.exit()System.exit()其实是Java中结束进程的方法，调用它将关闭当前的JVM虚拟机。 System.exit(0)和System.exit(1)的区别 System.exit(0)表示是正常退出； System.exit(1)表示是非正常退出，通常这种退出方式应该放在catch块中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hook(钩子函数)动态注入代码]]></title>
      <url>%2F2016%2F08%2F13%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FHook(%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0)%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[背景介绍很多时候系统处于安全考虑，将很多东西对外隐藏，而有时我们偏偏又不得不去使用这些隐藏的东西。甚至，我们希望向系统中注入一些自己的代码，以提高程序的灵活性。刚好有这么一种特殊的回调模式，Hook模式可以实现上述愿景。 Hook动态注入代码Hook机制是回调机制的一种，普通的回调是静态的，我们必须提前写好回调接口；而Hook机制在Java中则可以利用反射，针对切入点(通常是一个成员变量)，采用替换的手段，使代码在运行时改变，听起来有些抽象，下面简单介绍下，然后我看代码。 寻找适合Hook点，它应该是一个成员变量，并且应该在我们需要注入的方法中调用过它的方法，或者使用了它的的值； 创建继承自Hook点的对象的子类，根据需求修改其相应的方法； 使用反射将我们自己创建的对象替换对象实例中的对象，达到偷梁换柱的目的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Hero &#123; private Weapon weaponMain; public Hero(Weapon weaponMain) &#123; this.weaponMain = weaponMain; &#125; public void attack()&#123; weaponMain.attack(); &#125;&#125;public class Weapon &#123; int damage = 10; public void attack()&#123; System.out.println(String.format("对目标造成 %d 点伤害",damage)); &#125;&#125;public class Game&#123; public static void main(String[] args)&#123; Hero hero = new Hero(new Weapon()); hero.attack(); &#125;&#125;//对于上面这段程序，游戏对我们隐藏了Weapon的伤害值，但现在我们想要在每次攻击的时候知道这个伤害值是多少。//下面看看使用Hook机制如何来实现。//首先我们通过观察，发现切入点就是weaponMain，我们要对它下手。//创建一个Weapon的复制品WeaponHook，我们需要用自己的人WeaponHook打入内部。//WeaponHook一切看起来都和Weapon那么相似，但是我们给它留了一个后门，使得我们可以进行监控。public class WeaponHook extends Weapon&#123; private OnUseWeaponAttackListener onUseWeaponAttackListener; @Override public void attack()&#123; super.attack(); if (onUseWeaponAttackListener != null)&#123; onUseWeaponAttackListener.onUseWeaponAttack(damage); &#125; &#125; public void setOnUseWeaponAttackListener(OnUseWeaponAttackListener onUseWeaponAttackListener) &#123; this.onUseWeaponAttackListener = onUseWeaponAttackListener; &#125;//这就是我们的后门 public static interface OnUseWeaponAttackListener &#123; int onUseWeaponAttack(int damage); &#125;&#125;//下面看看如何来进行“偷天换日”public class Game&#123; public static void main(String[] args)&#123; Hero hero = new Hero(new Weapon()); try &#123; Field weapon = ReflectUtils.getVariable(hero.getClass(), "weaponMain"); weapon.setAccessible(true); Weapon weaponHook = new WeaponHook(); ((WeaponHook) weaponHook).setOnUseWeaponAttackListener(damage -&gt; &#123; //通过后门进行操作，这其实就是我们注入的代码 System.out.println("damage = " + damage); return damage; &#125;); weapon.set(hero, weaponHook); //tou tian偷天换日 hero.attack(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;Hero hero = new Hero(new Weapon()); hero.attack(); &#125;&#125;//看输出对目标造成 10 点伤害damage = 10 //我们获得了Weapon的伤害值 总结由于内容不多，总结我就不回顾前面了，我们来看看一种防止Hook入侵的一种思路。我们在Hero类中加入一个检查机制。12345678910111213141516public class Hero &#123; private Weapon weaponMain; private final int weaponMainId; public Hero(Weapon weaponMain) &#123; this.weaponMain = weaponMain; weaponMainId = this.weaponMain.hashCode();//记录原始Weapon对象的Id，hashCode对于每个对象而言都是唯一的。 &#125; public void attack() &#123; if (this.weaponMain.hashCode() != weaponMainId) &#123; //关键位置检查是否遭到替换 throw new IllegalAccessError(String.format("警告！遭到入侵！入侵者身份:%d", this.weaponMain.hashCode())); &#125; weaponMain.attack(); &#125;&#125; 现在再次运行程序，输出如下：1java.lang.IllegalAccessError: 警告！遭到入侵！入侵者身份:1288141870]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android之ClassLoader]]></title>
      <url>%2F2016%2F08%2F12%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FAndroid%E4%B9%8BClassLoader%2F</url>
      <content type="text"><![CDATA[参考资料参考资料;包括热修复; 背景介绍Java程序是由一个个.class文件组成的，在程序执行阶段，JVM采用了动态加载的策略，当一个类被使用时，将由一个ClassLoad实例去加载这个.class文件。Java允许我们从外部加载一个类到内存中，然后使用它。 有关ClassLoaderJava中ClassLoader的分类(1) BootstarpClassLoad：启动类加载器，它负责在程序启动时去加载Java的核心库。 (2) ExtensioClassLoad：扩展类加载器，它负责加载扩展库。 (3) AppClassLoad：系统类加载器，它负责加载classpath下的.class文件。 (4) CustomClassLoader：自定义的ClassLoader ClassLoader的加载机制ClassLoader采用了双亲委托加载机制 ，先看看下面的图解。 可以看到，ClassLoader在加载一个类时，会先自下而上的检查目标时候被加载了； 然后，自上而下的依次尝试去加载目标，如果到最后一层ClassLoader仍然没有加载到，就会抛出ClassNotFoundException 错误。 注意图中每种类型ClassLoader负责的范围。 开始自定义ClassLoader认识关键方法 findClass(String name)：这个方法顾名思义负责查找一个类，并返回它。对我们自定义而言，这是我们最需要关注的，一般情况下，我们只需要直接在这个方法中返回目标类就可以了，这也是Google推荐我们的做法。 loadClass(String name)：这个方法中主要负责协调加载类，通常它的逻辑比较固定，我们可以不去重写。在这个方法中，先尝试通过父类ClassLoader去加载目标类，没有加载到，然后调用findClass()方法去查找。 defineClass(String name, byte[] b, int off, int len)：负责定义类，这个方法我们主要调用就好了。 看看例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class CustomClassLoader extends ClassLoader &#123; private String classPath; public CustomClassLoader(String classPath) &#123; super(CustomClassLoader.class.getClassLoader()); this.classPath = classPath; &#125; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; if (classPath == null || classPath.equals("")) &#123; throw new IllegalArgumentException("Please set class path first."); &#125; byte[] classData = loadClassData(classPath); if (classData == null) &#123; throw new NullPointerException( "Try to get the byte[] that read from class file, but mate some problem. Please check class file path."); &#125; return defineClass(name, classData, 0, classData.length); // 将class的字节数组解码为Class实例 &#125; /** * 读取Class文件 */ private byte[] loadClassData(String path) &#123; byte[] bytes = new byte[1024]; int length = 0; ByteArrayOutputStream baos = new ByteArrayOutputStream(); File classFile = new File(path); FileInputStream fis = null; try &#123; fis = new FileInputStream(classFile); while ((length = fis.read(bytes)) != -1) &#123; baos.write(bytes, 0, length); baos.flush(); &#125; return baos.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fis == null) &#123; throw new NullPointerException( "Can not create FileInputStream, please check the file path."); &#125; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; public void setClassPath(String classPath) &#123; this.classPath = classPath; &#125;&#125;//下面来看看怎么使用public class MyClass &#123; public static void main(String[] args)&#123; CustomClassLoader classLoader = new CustomClassLoader(""); try &#123; classLoader.setClassPath("/Users/.../TestClass.class"); Class clazz = classLoader.loadClass("TestClass"); Method method = ReflectUtils.getMethod(clazz,"doSomething"); System.out.println(clazz.getSimpleName()); System.out.println("result = " + method.invoke(clazz.newInstance())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;//下面是TestClasspublic class TestClass &#123; public int doSomething()&#123; return 998; &#125;&#125;//下面是输出结果TestClassresult = 998 JVM如何判断两个类是否相同 是否具有相同类名； 是否由同一个ClassLoader加载。 总结其实Java已经做了很多工作，我们自定义ClassLoader要做的事就一件：读取.class文件 。其余的通常不需要修改。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Exception异常的正确打开方式]]></title>
      <url>%2F2016%2F08%2F11%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FException%E5%BC%82%E5%B8%B8%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[背景介绍我们每天都需要与各种个样的异常打交到，但是我们对异常了解吗？对其处理方式正确吗？了解的话就算了，不了解的可以看看下面的内容。 打开ExceptionException的分类先来看看下面这张图：从图中可以看出： Error(错误)和Exception(异常)都继承自Throwable类，我们重点关注Exception； 异常类分为检查异常(直接继承自Exception，除RuntimeException)和可不检查异常(Error和继承自RuntimeException的)； throw和throws的区别 throw通常在代码片段中用于直接抛出异常。 123public void test()&#123; throw new ClassNotFoundException();&#125; throws用在方法签名上，可抛出多种异常 123public void test() throws IOException, ArrayIndexOutOfBoundsException&#123; do something...&#125; 自定义异常只需要继承Exception就可以了。1234567891011public class CustomException extends Exception&#123; public CustomException(String exceptionInfo)&#123; super(exceptionInfo); &#125;&#125;//使用CustomExeptionpublic void test()&#123; throw new CustomException("抛出了自定义异常");&#125; try-catch-finally我们都很熟悉使用try-catch-finally去捕获异常，但现在值得思考一下我们之前写的try-catch-finally是否正确了。Code Clean 指出，try-catch-finally代码块在程序中定义了一个范围，我们应该让它的语意更明确，所以不应该把大段的代码放在其中，而应该抽离出来。来看看下面这个例子。123456789101112//这个方法中只定义了try-catch，而真正的操作放到deletePagerAndAllReference()中进行public void delete()&#123; try&#123; deletePagerAndAllReference(); &#125; catch (Exception e)&#123; Log.e(e); &#125;&#125;public void deletePagerAndAllReference() throws Exception&#123; //do delete&#125; 需要注意，catch中的return语句会在finally执行完成后才会被执行。 关于方法返回null的讨论在Code Clean 中，鲍勃大叔严厉批评了return null 这种骇人听闻的做法，这让程序中充满了类似obj ！= null 的判断。他建议在可能返回null的地方使用抛出异常，或者直接返回一种特例情况。例如下面这样：1234List&lt;Employee&gt; employees = getEmployees();if(employees != null)&#123; // doSomething...&#125; 由于getEmployees()可能返回null值，所以我们不得不每次调用的时候都去检查是否为null，但如果做如下更改：123456public List&lt;Employee&gt; getEmployees()&#123; if(..there are no employees..)&#123; return Collections.emptyList(); //没有数据返回一个空的List，调用时就不必去检查它是否为空了 &#125;&#125; 或者像下面这样：123456public List&lt;Employee&gt; getEmployees()&#123; if(..there are no employees..)&#123; throw new NullPointerException("嘿！List&lt;Employee&gt;不能为null,仔细检查下吧！"); //没有数据返回一个空的List，直接抛出异常，让调用者们知道，这个地方存在错误，不该让List&lt;Employee&gt;为null的。 &#125;&#125; Android中处理未捕获异常，并上报异常信息在我们的应用中，可能存在一些我们没有捕获的异常，对于这些异常，我们可以把它保存下来，然后进行分析。来看看怎么做。首先我们需要implements Thread.UncaughtExceptionHandler 实现自己的异常处理类，然后调用 Thread.setDefaultUncaughtExceptionHandler() 方法把我们的异常处理器设置到系统中，这样有为捕获的异常出现时，就能被我们自己处理了。当然，有一个重要的方法需要重写uncaughtException() 。下面看看完整例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class CrashHandler implements UncaughtExceptionHandler &#123; private static final CrashHandler mInstance = new CrashHandler(); private UncaughtExceptionHandler mDefualtCrashHandler; private Context mContext; /** * 防止被重复创建 */ private CrashHandler() &#123;&#125; public static CrashHandler getInstance() &#123; return mInstance; &#125; public void init(Context context) &#123; mContext = context.getApplicationContext(); // 确保获得的是系统级的Context mDefualtCrashHandler = Thread.getDefaultUncaughtExceptionHandler(); // 获取系统默认的异常处理器 Thread.setDefaultUncaughtExceptionHandler(this); // 把当前实例设置为系统默认异常处理器 &#125; /** * 这个方法是我们重写的重点，当系统出现未捕获异常时，就会调用这个方法 * * @param t 出现未捕获异常的线程 * @param e 未捕获的异常 */ @Override public void uncaughtException(Thread t, Throwable e) &#123; try &#123; saveExceptionToFile(e); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; if (mDefualtCrashHandler != null) &#123; //如果系统有默认异常处理就使用它处理 mDefualtCrashHandler.uncaughtException(t, e); &#125; else &#123; //否则我们自行结束程序 android.os.Process.killProcess(Process.myPid()); &#125; &#125; private void saveExceptionToFile(Throwable e) throws IOException&#123; if (FileUtils.ExistSDCard())&#123; long currentTime = System.currentTimeMillis(); String crashTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(currentTime); File file = new File(FileUtils.getAppCrashDir()+"crash" + crashTime + ".txt"); file.createNewFile(); try&#123; PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file))); pw.println(crashTime); printPhoneInfo(pw); pw.println(); e.printStackTrace(pw); //输出错误信息 pw.close(); &#125; catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125; &#125; /** * 输出手机信息 */ private void printPhoneInfo(PrintWriter pw) throws PackageManager.NameNotFoundException &#123; PackageManager pm = mContext.getPackageManager(); PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(), PackageManager.GET_ACTIVITIES); pw.print("App version: "); pw.print(pi.versionName); pw.print("_"); pw.println(pi.versionCode); //android版本号 pw.print("OS Version: "); pw.print(Build.VERSION.RELEASE); pw.print("_"); pw.println(Build.VERSION.SDK_INT); //制造商 pw.print("Vendor: "); pw.println(Build.MANUFACTURER); //手机型号 pw.print("Model: "); pw.println(Build.MODEL); //cpu架构 pw.print("CPU ABI: "); pw.println(Build.CPU_ABI); &#125;&#125; 看看怎么使用。1234567891011121314public class IceApplication extends MultiDexApplication &#123; private static Context context; @Override public void onCreate() &#123; super.onCreate(); context = this; //初始化异常处理类，这样我们的异常类就生效了 CrashHandler.getInstance().init(context); &#125; public static Context getAppContext()&#123; return context; &#125;&#125; 总结现在我们对异常有了一定的了解，从现在开始，在编程过程中要开始注意对异常的处理艺术了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[StackTraceElement线程运行栈的探索]]></title>
      <url>%2F2016%2F08%2F10%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FStackTraceElement%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%A0%88%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[介绍StackTraceElement[]中保存了一条线程中所有调用的方法。其中每个方法的信息包含在一个StackTraceElement对象中。 获取StackTraceElement中的信息1234element.getClassName(); //获取类名element.getMethodLine(); //获取方法名element.getMethodName(); //获取方法名element.getFileName(); //获取包含类的文件名 StackTraceElement[]中的信息StackTracelElement[]是一个的数组，以下标1为开始，其中在Java比较有用的是第3个，在Android中比较有用的是第4个,因为在Android中多了一个Dalvik的调用，所以实际Java中的第3位向后移动了一个位置，变成第4位。这个比较有用的StackTraceElement保存了实际调用该方法的方法信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//下面方法能够打印一组当前线程的StackTraceElement[]信息：public static String showAllElementsInfo() &#123; String print = ""; int count = 0; //从当前线程中获取所有的StackTraceElement StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace(); for (StackTraceElement stackTraceElement : stackTraceElements) &#123; count++; print += String.format("ClassName:%s " + "\nMethodName:%s " + "\nMethodLine:%d " + "\n当前是第%d个 " + "\n---------------------------- " + "\n ", stackTraceElement.getClassName(), stackTraceElement.getMethodName(), stackTraceElement.getLineNumber(), count); &#125; return print; &#125; //我是在单元测试中调用的 @Test public void testTestElement() throws Exception &#123; System.out.println(LogUtils.showAllElementsInfo()); &#125;//下面是测试打印结果：ClassName:java.lang.Thread MethodName:getStackTrace MethodLine:1552 当前是第1个 ---------------------------- ClassName:com.example.chenbing.animdvedemo.Utils.LogUtils MethodName:showAllElementsInfo MethodLine:60 当前是第2个 ---------------------------- ClassName:com.example.chenbing.animdvedemo.Utils.LogUtilsTest MethodName:testTestElement MethodLine:32 当前是第3个 ---------------------------- ClassName:sun.reflect.NativeMethodAccessorImpl MethodName:invoke0 MethodLine:-2 当前是第4个 ---------------------------- ClassName:sun.reflect.NativeMethodAccessorImpl MethodName:invoke MethodLine:62 当前是第5个 ---------------------------- ClassName:sun.reflect.DelegatingMethodAccessorImpl MethodName:invoke MethodLine:43 当前是第6个 ---------------------------- ClassName:java.lang.reflect.Method MethodName:invoke MethodLine:498 当前是第7个 ---------------------------- ClassName:org.junit.runners.model.FrameworkMethod$1 MethodName:runReflectiveCall MethodLine:50 当前是第8个 ---------------------------- ClassName:org.junit.internal.runners.model.ReflectiveCallable MethodName:run MethodLine:12 当前是第9个 ---------------------------- ClassName:org.junit.runners.model.FrameworkMethod MethodName:invokeExplosively MethodLine:47 当前是第10个 ---------------------------- ClassName:org.junit.internal.runners.statements.InvokeMethod MethodName:evaluate MethodLine:17 当前是第11个 ---------------------------- ClassName:org.junit.internal.runners.statements.RunBefores MethodName:evaluate MethodLine:26 当前是第12个 ---------------------------- ClassName:org.junit.internal.runners.statements.RunAfters MethodName:evaluate MethodLine:27 当前是第13个 ---------------------------- ClassName:org.junit.runners.ParentRunner MethodName:runLeaf MethodLine:325 当前是第14个 ---------------------------- ClassName:org.junit.runners.BlockJUnit4ClassRunner MethodName:runChild MethodLine:78 当前是第15个 ---------------------------- ClassName:org.junit.runners.BlockJUnit4ClassRunner MethodName:runChild MethodLine:57 当前是第16个 ---------------------------- ClassName:org.junit.runners.ParentRunner$3 MethodName:run MethodLine:290 当前是第17个 ---------------------------- ClassName:org.junit.runners.ParentRunner$1 MethodName:schedule MethodLine:71 当前是第18个 ---------------------------- ClassName:org.junit.runners.ParentRunner MethodName:runChildren MethodLine:288 当前是第19个 ---------------------------- ClassName:org.junit.runners.ParentRunner MethodName:access$000 MethodLine:58 当前是第20个 ---------------------------- ClassName:org.junit.runners.ParentRunner$2 MethodName:evaluate MethodLine:268 当前是第21个 ---------------------------- ClassName:org.junit.runners.ParentRunner MethodName:run MethodLine:363 当前是第22个 ---------------------------- ClassName:org.junit.runner.JUnitCore MethodName:run MethodLine:137 当前是第23个 ---------------------------- ClassName:com.intellij.junit4.JUnit4IdeaTestRunner MethodName:startRunnerWithArgs MethodLine:69 当前是第24个 ---------------------------- ClassName:com.intellij.rt.execution.junit.JUnitStarter MethodName:prepareStreamsAndStart MethodLine:234 当前是第25个 ---------------------------- ClassName:com.intellij.rt.execution.junit.JUnitStarter MethodName:main MethodLine:74 当前是第26个 ---------------------------- ClassName:sun.reflect.NativeMethodAccessorImpl MethodName:invoke0 MethodLine:-2 当前是第27个 ---------------------------- ClassName:sun.reflect.NativeMethodAccessorImpl MethodName:invoke MethodLine:62 当前是第28个 ---------------------------- ClassName:sun.reflect.DelegatingMethodAccessorImpl MethodName:invoke MethodLine:43 当前是第29个 ---------------------------- ClassName:java.lang.reflect.Method MethodName:invoke MethodLine:498 当前是第30个 ---------------------------- ClassName:com.intellij.rt.execution.application.AppMain MethodName:main MethodLine:144 当前是第31个 ----------------------------]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存抖动]]></title>
      <url>%2F2016%2F08%2F09%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2F%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[参考资料Google官方讲解视屏 背景介绍在Java内存管理机制中我提到过内存抖动会引起频繁的GC，从而使UI线程被频繁阻塞，导致画面卡顿。这次我们就聊聊内存抖动。 需要避免内存抖动内存抖动是由于短时间内有大量对象进出Young Generiation区导致的，它伴随着频繁的GC。通常存在内存抖动时，我们可以在Android Studio的Monitors中看到如下场景：下面是避免发生内存抖动的几点建议： 尽量避免在循环体内创建对象，应该把对象创建移到循环体外。 注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。 当需要大量使用Bitmap的时候，试着把它们缓存在数组中实现复用。 对于能够复用的对象，同理可以使用对象池将它们缓存起来。 总结总之，因为内存抖动是由于大量对象在短时间内被配置而引起的，所以我们要做的就是谨慎对待那些可能会大量创建对象的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存泄漏]]></title>
      <url>%2F2016%2F08%2F08%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
      <content type="text"><![CDATA[背景介绍内存泄漏一种情况是一块内存没有引用指向它，却没被回收，这种情况已经由Java虚拟机的GC帮助我们处理好了，见Java内存管理机制；另一种属于逻辑内存泄漏，即一个对象已经不再被使用了，但它仍然被另一个被使用中的对象所持有，导致该对象所占用的内存块不能被回收。 少部分内存泄漏看不出有什么影响，但如果大量发生，将会明显减少可用内存，导致频繁GC，运行缓慢，严重时将容易引发OutOfMemoryError。 Android中常见的内存泄漏集合引发的泄漏一些对象缓存到集合中，当它不在被使用时，没有从集合中移除，就造成了泄漏。 Activity中的泄漏一个Activity中的Context通常会被很多地方引用，如果在Activity执行了onDestory()后这些引用没有被置空，将会导致Activity无法被回收。而Activity中依赖了很对对象，这些对象将都不能被回收，所以一定要十分小心Activity的泄漏。以下几种常见的情况需要注意： 当创建一个对象，该对象需要Context作为参数时。当该对象在Activity执行了onDestory()后仍然可到达，那么它持有的Activity就无法被回收。 使用Handler时。Handler会间接的持有Activity的引用(在Activity中new的Handler持有的主线程的Loop)，当Activity执行了onDestory()后，若Handler仍未被释放，那么Activity也将不会被释放。解决方法： 需要在onDestory()完成前确保Handler没有执行yan shi延时任务，没有被其他地方引用。同时清理Handler中所有任务，调用removeCallbacksAndMessages(null);,该方法参数为空时会移除所以的CallBack和Message。 另一种方法是自定义一个静态内部Handler，让它持有的Activity为弱引用。1234567891011121314static class MyHandler extends Handler &#123; private final WeakReference&lt;Activity&gt; mActivity; public MyHandler(Activity activity) &#123; mActivity = new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; System.out.println(msg); if (mActivity.get() == null) &#123; return; &#125; mActivity.get().todo(); &#125; &#125; 在异步任务中引用Activity或Context，而没有在Activity销毁前停止线程，就会导致Activity的泄漏。 内部类、匿名内部类会持有外部类的实例，所以在Activity中使用内部类或匿名内部类，并且奖该类创建的对象传递给其他对象，若该对象在Activity之外被引用，或是在仍在进行的异步任务中，那么Activity将不能释放。Bitmap引发的内存泄漏Bitmap是引用中占用内存的大户，在使用时一定要十分注意。当Bitmap不用时，应该及时调用recycle()释放其申请的内存。异步任务引发的泄漏异步任务如果在它应该停止的时候没有停止，那它本身及它所依赖的对象将都不能被正确的释放。比如上面提到的Activity中的异步任务。总结由于系统内存资源有限，所以我们需要尽量避免内存泄漏，以保证程序能够流畅运行。 由于Activity泄漏将会连带大量的对象一起泄漏，所以在Activity中写代码应该特别注意Handler、内部类及匿名内部类，还有Context不能随便传递。 使用异步任务时一定要明确其作用范围，在应该停止的时候记得停止。 Bitmap占用内存通常较大，所以在使用完后及时释放十分重要。 此外，在传递参数到单例中时，也需要谨慎。tic class MyHandler extends Handler {private final WeakReference&lt;Activity&gt; mActivity; public MyHandler(Activity activity) { mActivity = new WeakReference&lt;Activity&gt;(activity); } @Override public void handleMessage(Message msg) { System.out.println(msg); if (mActivity.get() == null) { return; } mActivity.get().todo(); } }``` 在异步任务中引用Activity或Context，而没有在Activity销毁前停止线程，就会导致Activity的泄漏。 内部类、匿名内部类会持有外部类的实例，所以在Activity中使用内部类或匿名内部类，并且奖该类创建的对象传递给其他对象，若该对象在Activity之外被引用，或是在仍在进行的异步任务中，那么Activity将不能释放。Bitmap引发的内存泄漏Bitmap是引用中占用内存的大户，在使用时一定要十分注意。当Bitmap不用时，应该及时调用recycle()释放其申请的内存。异步任务引发的泄漏异步任务如果在它应该停止的时候没有停止，那它本身及它所依赖的对象将都不能被正确的释放。比如上面提到的Activity中的异步任务。总结由于系统内存资源有限，所以我们需要尽量避免内存泄漏，以保证程序能够流畅运行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView——使用ItemDragHelper来实现酷炫拖拽效果]]></title>
      <url>%2F2016%2F08%2F08%2FRecyclerView%2FRecyclerView%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8ItemDragHelper%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%85%B7%E7%82%AB%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[参考资料参考资料1参考资料2参考资料3【推荐】 背景介绍列表控件可以说是我们绝大部分App中都会使用的，为了提升交互乐趣，我们经常需要在列表中加入拖拽、滑动等操作，本篇我将介绍使用ItemDragHelper这个官方提供的交互帮助类来帮助RecyclerView实现这些复杂的交互。 走进ItemTouchHelper要使用这个类，最关键的步骤是传给它一个ItemTouchHelper.Callback，其它的我们可以不用管。既然它是一个Callback，那么我们可以大概猜到，我们自然就是在它的一些回调函数里做操作了。下面我们就来看看我们需要在哪些回调函数里做操作。先上个效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class CustomItemTouchHelperCallback extends ItemTouchHelper.Callback &#123; private OnItemTouchCallbackListener onItemTouchCallbackListener; private boolean canDrag = true; private boolean canSwipe = true; public CustomItemTouchHelperCallback(OnItemTouchCallbackListener onItemTouchCallbackListener) &#123; this.onItemTouchCallbackListener = onItemTouchCallbackListener; &#125; @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); int dragFlags = 0; int swipeFlags = 0; if (layoutManager instanceof GridLayoutManager) &#123; // 如果是Grid布局，则不能滑动，只能上下左右拖动 dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; swipeFlags = 0; &#125; else if (layoutManager instanceof LinearLayoutManager) &#123; // 如果是纵向Linear布局，则能上下拖动，左右滑动 if (((LinearLayoutManager) layoutManager).getOrientation() == LinearLayoutManager.VERTICAL) &#123; dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; swipeFlags = ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT; &#125; else &#123; // 如果是横向Linear布局，则能左右拖动，上下滑动 swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; dragFlags = ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT; &#125; &#125; return makeMovementFlags(dragFlags, swipeFlags); //该方法指定可进行的操作 &#125; /** * 拖动时回调，在这里处理拖动事件 * * @param viewHolder 被拖动的view * @param target 目标位置的view */ @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; //这里我们直接将参数传递到回调接口方法中，提高复用性 return onItemTouchCallbackListener.onMove(recyclerView, viewHolder, target); &#125; /** * 滑动时回调 * * @param direction 回调方向 */ @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; onItemTouchCallbackListener.onSwiped(viewHolder, direction); &#125; /** * 在这个回调中，如果返回true，表示可以触发长按拖动事件，false则表示不能 */ @Override public boolean isLongPressDragEnabled() &#123; return canDrag; &#125; /** * 在这个回调中，如果返回true，表示可以触发滑动事件，false表示不能 */ @Override public boolean isItemViewSwipeEnabled() &#123; return canSwipe; &#125; public void setCanDrag(boolean canDrag) &#123; this.canDrag = canDrag; &#125; public void setCanSwipe(boolean canSwipe) &#123; this.canSwipe = canSwipe; &#125;&#125; 下面我们看看怎么来使用这个我们自定义的Callback。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class DraggerRecyclerViewActivity extends BaseActivity &#123; @BindView(R.id.rv_dragger_list) RecyclerView draggerList; private List&lt;String&gt; datas = new ArrayList&lt;&gt;(); private TextTestAdapter adapter; private CustomItemTouchHelper itemTouchHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dragger_recycler_view); ButterKnife.bind(this); initData(); initView(); addListener(); &#125; @Override protected void initData() &#123; for (int i = 0; i &lt; 100; i++) &#123; datas.add("我是Item" + i); &#125; &#125; @Override protected void initView() &#123; draggerList.setItemAnimator(new DefaultItemAnimator()); draggerList.addItemDecoration(new RecyclerView.ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (itemPosition != parent.getChildCount() - 1) &#123; outRect.bottom = (int) DisplayUtils.dipToPx(0.5f); &#125; &#125; &#125;); draggerList.setLayoutManager(new LinearLayoutManager(this)); adapter = new TextTestAdapter(this, datas); //创建ItemTouchHelper itemTouchHelper = new CustomItemTouchHelper(new OnItemTouchCallbackListener() &#123; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; if (datas == null) &#123; return false; &#125; //处理拖动排序 //使用Collection对数组进行重排序，目的是把我们拖动的Item换到下一个目标Item的位置 Collections.swap(datas, viewHolder.getAdapterPosition(), target.getAdapterPosition()); //通知Adapter它的Item发生了移动 adapter.notifyItemMoved(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true; &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; if (datas == null) &#123; return; &#125; //处理滑动删除 //直接从数据中删除该Item的数据 datas.remove(viewHolder.getAdapterPosition()); //通知Adapter有Item被移除了 adapter.notifyItemRemoved(viewHolder.getAdapterPosition()); &#125; &#125;); //并绑定RecyclerView itemTouchHelper.attachToRecyclerView(draggerList); draggerList.setAdapter(adapter); &#125; @Override protected void addListener() &#123; &#125;&#125; 下面是ItemTouchHelper。1234567public class CustomItemTouchHelper extends ItemTouchHelper &#123; public CustomItemTouchHelper(OnItemTouchCallbackListener onItemTouchCallbackListener) &#123; //直接把回调交给父类处理就好 super(new CustomItemTouchHelperCallback(onItemTouchCallbackListener)); &#125;&#125; 很简单是不是？把它自定义出来其实就是为了防止后期还要添加别的操作，如果不需要，可以直接用API中的ItemTouchHelper。 总结归根结底，使用ItemTouchHelper来实现RecyclerView的拖拽、滑动操作，最主要的还是重写ItemTouchHelper.Callback，在这个回调中，比较重要的方法是以下几个： getMovementFlags(): 这个方法中需要返回可进行的操作Flags，这些Flags需要调用下面的方法合成； makeMovementFlags()：这个方法将drag和move操作的Flags合成，作为getMovementFlags中的返回项； onMove()：发生拖动时调用； onSwiped()：发生滑动时调用； isLongPressDragEnabled()：是否能触发长按拖动； isItemViewSwipeEnabled()：是否能触发滑动；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存管理机制]]></title>
      <url>%2F2016%2F08%2F08%2FAndroid%E4%B9%8B%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2FJava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[参考链接参考资料1 背景介绍 Java优势之一就是其具有垃圾回收机制。在大部分情况下，JVM的GC(垃圾回收器)能够帮助我们回那些不可到达的对象(就是未被引用的对象)。 当然，在一些情况下，我们仍然需要自己去释放内存(就是把对象置null，把容器、数组清空)，否则就会引起内存泄漏，内存泄漏严重时将容易引发OutOfMemoryError，详情见内存泄漏。 此外，由于GC会停止所有的线程，包括UI线程，所以频繁的GC必然会导致画面卡顿(Android中每16ms为一帧)，因此还应避免GC的频繁发生。一个导致GC频繁发生的原因就是内存抖动，点击链接看详情。 所以，理解Java的内存机制，有助于帮助我们在写代码的过程中避免内存泄漏。基本概念Java内存层级Heap Segment在Java8之后，Heap Segment真正意义上的是由Young Generiation和Old Generiation组成的。对象在其中是标记复制算法来判定一个对象是否应该被清理掉。Heap Segment中发生的GC称为Major GC，只会影响Heap Segment区。Young Generiation中的GC变化 当对象被创建后，首先会被加入eden区。当eden区满了之后，就会触发一次GC，存活下来的对象会被复制到survivor区。 当不为空的Survivor区满了，同样会触发一次GC。 当短时间内有大量对象创建和释放同样会造成内存抖动，会触发CG。 如图所示，survivor有两个区域，其中一个总是保持为空。 现假设两个Survivor区分别为S0，S1，并且首次GC时，eden区中存活的对象被复制到S0中。当再次发生GC时，S0和eden中仍然存活的对象就会被复制到空的S1中，此时S0为空；再次发生GC时，S1和eden中存活的对象将被复制到S0中，此时S1为空；再次发生GC…就是这样进行的。当一个对象被来回复制转移的次数达到阀值(默认为15次，可以通过使用-XX:MaxTenuringThreshold该命令来调整阀值)时，这个对象将被复制到Old Generiation区中，此时该对象将会变的相对安全，因为Old Segment区的GC频率相对较低。Old Segment中的GC变化 该区域满了之后会触发一次GC，在该次GC中，一些年龄较大的对象会被清理掉。 若多次触发GC后，该区域仍然处于满的状态，则会抛出OutOfMemoryError。 以两种情况下，新建对象会被直接复制到该区域中: 当新建对象所需要的内存大于1/2的单个survivor区内存时； 当新建对象被该区中的对象引用时，或者引用了该区域中的对象。 总结 Java内存块被划分为：Code Segment、DataSegment、StackSegment、Heap Segment，其中Heap Segment由于设计对象的创建与销毁，所以它应该重点关注的对象。 Heap Segment又被划分为两块：Young Generiation和Old Generiation。 Young Genertiation中又被划分为Eden区和两个Survivor区，对象在其中采用标记复制算法来判定一个对象是应该清理还是移到Old Generiation中。该内存区域发生GC的频率较高。 Old Generiation发生GC的频率相对较低。当有大对象被创建，或者和该区域有关的对象被创建时，它将会被直接移动到该区域中。，就会触发一次GC，存活下来的对象会被复制到survivor区。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView——用ItemDecoration装饰你的Item]]></title>
      <url>%2F2016%2F08%2F07%2FRecyclerView%2FRecyclerView%E2%80%94%E2%80%94%E7%94%A8ItemDecoration%E8%A3%85%E9%A5%B0%E4%BD%A0%E7%9A%84Item%2F</url>
      <content type="text"><![CDATA[参考资料参考资料1； 背景介绍RecyclerView由于它强大的灵活性，已经可以代替掉传统的ListView和GridView等列表控件了。但是也因为它的灵活性，一些东西就没有固定，需要我们自己来实现，比如RecyclerView就没有提供默认的分割线，当我们需要一条分割线时，我们需要自己通过继承RecyclerView.ItemDecoration来实现。当然，它不仅仅可以实现分割线，还能创造很多不一样的效果，这取决于我们的想象力在这个限制范围内能到什么程度了。本篇我们来好好聊聊ItemDecoration。 认识ReccylerView.ItemDecoration为RecyclverView添加ItemDecoration我们可以通过调用：1mRecyclerView.addItemDecoration(mItemDecoration)； 来为我们的RecyclerView添加一个自定义的ItemDecoration装饰它。这里值得注意的是我们采用的是addXXX方法，这意味着我们可以为RcyclerView添加多个ItemDecoration。打开该方法的源码我们可以看到：1234567891011121314151617181920212223242526272829303132333435363738394041424344//这是我们通常调用的代码public void addItemDecoration(ItemDecoration decor) &#123; //这里又调用了另一个重载的方法 addItemDecoration(decor, -1); &#125; /** * Add an &#123;@link ItemDecoration&#125; to this RecyclerView. Item decorations can * affect both measurement and drawing of individual item views. * * &lt;p&gt;Item decorations are ordered. Decorations placed earlier in the list will * be run/queried/drawn first for their effects on item views. Padding added to views * will be nested; a padding added by an earlier decoration will mean further * item decorations in the list will be asked to draw/pad within the previous decoration's * given area.&lt;/p&gt; * * @param decor Decoration to add * @param index Position in the decoration chain to insert this decoration at. If this value * is negative the decoration will be added at the end. * 通过文档我们可以知道，index参数控制这我们add的ItemDecoration添加到mItemDecorations数组中的位置。如果小于0，我们的ItemDecoration将被添加到最后。 */public void addItemDecoration(ItemDecoration decor, int index) &#123; if (mLayout != null) &#123; mLayout.assertNotInLayoutOrScroll("Cannot add item decoration during a scroll or" + " layout"); &#125; if (mItemDecorations.isEmpty()) &#123; setWillNotDraw(false); //注意，当我们首次添加ItemDecoration时，mItemDecorations是一个空的数组， //但这事我们就需要让View开启自我绘制，否则RecyclerView的onDraw()方法将有可能不被执行。 //我们在写自定义ViewGroup时也需要注意这个问题。 &#125; if (index &lt; 0) &#123; //这个逻辑保证了小于0，添加到末尾 mItemDecorations.add(decor); &#125; else &#123; //添加到指定位置 mItemDecorations.add(index, decor); &#125; //这个方法最终把RecyclerView的Item的LayoutParams的mInsertDirty属性设置为true， //这样在measure时，才能够把所有的ItemDecoration中的itemOffset添加到Item的布局参数上。 markItemDecorInsetsDirty(); requestLayout(); &#125; 所以，我们可以多次调用addItemDecoration()，并且每次添加的ItemDecoration的itemOffset都将累加到Item的布局参数上。 自定义ItemDecoration对于自定义ItemDecoration我们通常仅仅关心以下3个方法就行。 getItemOffsets()这个方法有2个重载方法：12345678910111213public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; outRect.set(0, 0, 0, 0); //注意，重写时super要慎重使用，否则设置的Rect会被重置。 //通过上面的讲解，我们知道，在这里设置的outRect的参数最终都会被累加到Item的布局参数上。 //如果值设为负数，那么Item会发生重叠。 &#125;//这个方法主要能够方便的获取到View和当前RecyclerView的状态，//但它最终调用的仍然是上一个方法，所以重写这个方法需要注意super，最好就不要要。public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent); &#125; 这里借张图，侵删！ onDraw()该方法同样有两个重载方法：12345678910public void onDraw(Canvas c, RecyclerView parent)&#123; //在这个方法中利用Canvas绘制点什么， //它最终会绘制在Item的下一层，如果它超出Item，那么超出部分将可见。 //注意，计算Item的top时，记得加上Translation，否则不能准确计算&#125;//该方法最终还是调用上一个方法，所以要注意super，最好就不要。这个方法能够获取到RecyclerView状态。public void onDraw(Canvas c, RecyclerView parent, State state) &#123; onDraw(c, parent); &#125; 借张图，侵删！这里有个坑，在我使用mDrawable.canvas()来绘制分割线的时候，由于mDrawable.getIntrinscXXX()获得的值为-1，所以导致了绘制效果不可见。解决办法是在计算bottom或right时，直接指定我们所希望的间距，除非我们已经设置mDrawable的尺寸。 还有一点需要注意：最终getItemOffset()方法中设置的偏移距离会叠加到Item的布局尺寸参数上，而分割线的绘制应该在Item底部(去尾)，或者说Item顶部(去头)，绘制区域 onDrawOver()与onDraw()方法类似，不同的是它将被覆盖在Item上面。它同样有两个重载方法:12345678public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123; onDrawOver(c, parent); &#125;@Deprecatedpublic void onDrawOver(Canvas c, RecyclerView parent) &#123; &#125; 总结通过自定义ItemDecoration我们可以实现需要吊炸天的效果。先遵守规则，然后天马行空。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView——实现自定义LayoutManager]]></title>
      <url>%2F2016%2F08%2F06%2FRecyclerView%2FRecyclerView%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%2F</url>
      <content type="text"><![CDATA[参考资料参考资料1;参考资料2；参考资料3；参考资料4； 背景介绍RecyclerView由于其强大的扩展性，现在已经逐步的取代了ListView和GridView了。为了实现不同的布局效果，我们会用到官方提供的LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager。但这些布局只能满足日常需求，在一些比较复杂的布局中，它们就力不从心了，强行拼凑实现，带来的后果就是较差的体验和性能。所以能够自定义LayoutManager还是十分必要的，它能够解放创造力，构造复杂的、流畅的滑动列表。上面几篇参考资料中就实现了一些不寻常的效果，我们可以看到，这些效果如果用常规的方案去实现将会十分蹩脚。 揭开LayoutManager中不为人知的秘密自定义LayoutManager主要要求我们完成三件事情： 计算每个ItemView的位置； 处理滑动事件； 缓存并重用ItemView； 而我们比较重要的工作是在onLayoutChildern() 这个回调方法中完成的。 下面我们就来一一解析。 预先准备当我们extends RecyclerView.LayoutManager是，我们会被强制要求重写generateDefaultLayoutParams()方法，如方法名字一样，我们需要提供一个默认的LayoutParams，这里为我们的每个ItemView提供默认的LayoutParams，所以它能够直接影响到我们的布局效果，这里我们设置成WRAP_CONTENT，让ItemView获得决定权。12345@Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.WRAP_CONTENT, RecyclerView.LayoutParams.WRAP_CONTENT); &#125; 计算ItemView的位置1.实现简单的LayoutManager先看效果图:再看代码：1234567891011121314151617181920212223242526272829@Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; super.onLayoutChildren(recycler, state); // 先把所有的View先从RecyclerView中detach掉，然后标记为"Scrap"状态，表示这些View处于可被重用状态(非显示中)。 // 实际就是把View放到了Recycler中的一个集合中。 detachAndScrapAttachedViews(recycler); calculateChildrenSite(recycler); &#125; private void calculateChildrenSite(RecyclerView.Recycler recycler) &#123; totalHeight = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; // 遍历Recycler中保存的View取出来 View view = recycler.getViewForPosition(i); addView(view); // 因为刚刚进行了detach操作，所以现在可以重新添加 measureChildWithMargins(view, 0, 0); // 通知测量view的margin值 int width = getDecoratedMeasuredWidth(view); // 计算view实际大小，包括了ItemDecorator中设置的偏移量。 int height = getDecoratedMeasuredHeight(view); Rect mTmpRect = new Rect(); //调用这个方法能够调整ItemView的大小，以除去ItemDecorator。 calculateItemDecorationsForChild(view, mTmpRect); // 调用这句我们指定了该View的显示区域，并将View显示上去，此时所有区域都用于显示View， //包括ItemDecorator设置的距离。 layoutDecorated(view, 0, totalHeight, width, totalHeight + height); totalHeight += height; &#125; &#125; 这段代码逻辑简单，它实现的其实就是一个简单的垂直线性布局，当然现在还不能滑动，也没有缓存机制。在这段代码中，我们先调用detachAndScrapAttachedViews(recycler);将所有的ItemView标记为Scrap状态，然后在挨个取出来，计算他们应该布局到什么位置，并用成员变量totalHeight记录总高度，最后依次调用layoutDecorated()将ItemView布局上去。 2.两列式的LayoutManager先看效果图：有了上例的基础，我们只需要稍作调整，直接看下面代码，注意注释部分。123456789101112131415161718192021222324private void calculateChildrenSite(RecyclerView.Recycler recycler) &#123; totalHeight = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; View view = recycler.getViewForPosition(i); addView(view); //我们自己指定ItemView的尺寸。 measureChildWithMargins(view, DisplayUtils.getScreenWidth() / 2, 0); int width = getDecoratedMeasuredWidth(view); int height = getDecoratedMeasuredHeight(view); Rect mTmpRect = new Rect(); calculateItemDecorationsForChild(view, mTmpRect); if (i % 2 == 0) &#123; //当i能被2整除时，是左，否则是右。 //左 layoutDecoratedWithMargins(view, 0, totalHeight, DisplayUtils.getScreenWidth() / 2, totalHeight + height); &#125; else &#123; //右，需要换行 layoutDecoratedWithMargins(view, DisplayUtils.getScreenWidth() / 2, totalHeight, DisplayUtils.getScreenWidth(), totalHeight + height); totalHeight = totalHeight + height; LogUtils.e(i + "-&gt;" + totalHeight); &#125; &#125; &#125; 处理滑动先来看一下效果: 滑动事件主要涉及到4个方法需要重写，我们直接来看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Override public boolean canScrollVertically() &#123; //返回true表示可以纵向滑动 return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //列表向下滚动dy为正，列表向上滚动dy为负，这点与Android坐标系保持一致。 //实际要滑动的距离 int travel = dy; LogUtils.e("dy = " + dy); //如果滑动到最顶部 if (verticalScrollOffset + dy &lt; 0) &#123; travel = -verticalScrollOffset; &#125; else if (verticalScrollOffset + dy &gt; totalHeight - getVerticalSpace()) &#123;//如果滑动到最底部 travel = totalHeight - getVerticalSpace() - verticalScrollOffset; &#125; //将竖直方向的偏移量+travel verticalScrollOffset += travel; // 调用该方法通知view在y方向上移动指定距离 offsetChildrenVertical(-travel); return travel; &#125; private int getVerticalSpace() &#123; //计算RecyclerView的可用高度，除去上下Padding值 return getHeight() - getPaddingBottom() - getPaddingTop(); &#125; @Override public boolean canScrollHorizontally() &#123; //返回true表示可以横向滑动 return super.canScrollHorizontally(); &#125; @Override public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //在这个方法中处理水平滑动 return super.scrollHorizontallyBy(dx, recycler, state); &#125; 缓存并重用ItemView在上面代码的基础上我们稍作改动，加入缓存，先看下面的log信息，它显示虽然有100个Item，但childCount稳定在26：下面来看看代码的变化，我展示了完整的代码，留心注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class CustomLayoutManager extends RecyclerView.LayoutManager &#123; /** 用于保存item的位置信息 */ private SparseArray&lt;Rect&gt; allItemRects = new SparseArray&lt;&gt;(); /** 用于保存item是否处于可见状态的信息 */ private SparseBooleanArray itemStates = new SparseBooleanArray(); public int totalHeight = 0; private int verticalScrollOffset; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() &lt;= 0 || state.isPreLayout()) &#123; return; &#125; super.onLayoutChildren(recycler, state); detachAndScrapAttachedViews(recycler); /* 这个方法主要用于计算并保存每个ItemView的位置 */ calculateChildrenSite(recycler); recycleAndFillView(recycler, state); &#125; private void calculateChildrenSite(RecyclerView.Recycler recycler) &#123; totalHeight = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; View view = recycler.getViewForPosition(i); addView(view); // 我们自己指定ItemView的尺寸。 measureChildWithMargins(view, DisplayUtils.getScreenWidth() / 2, 0); calculateItemDecorationsForChild(view, new Rect()); int width = getDecoratedMeasuredWidth(view); int height = getDecoratedMeasuredHeight(view); Rect mTmpRect = allItemRects.get(i); if (mTmpRect == null) &#123; mTmpRect = new Rect(); &#125; if (i % 2 == 0) &#123; // 当i能被2整除时，是左，否则是右。 // 左 mTmpRect.set(0, totalHeight, DisplayUtils.getScreenWidth() / 2, totalHeight + height); &#125; else &#123; // 右，需要换行 mTmpRect.set(DisplayUtils.getScreenWidth() / 2, totalHeight, DisplayUtils.getScreenWidth(), totalHeight + height); totalHeight = totalHeight + height; &#125; // 保存ItemView的位置信息 allItemRects.put(i, mTmpRect); // 由于之前调用过detachAndScrapAttachedViews(recycler)，所以此时item都是不可见的 itemStates.put(i, false); &#125; &#125; private void recycleAndFillView(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() &lt;= 0 || state.isPreLayout()) &#123; return; &#125; // 当前scroll offset状态下的显示区域 Rect displayRect= new Rect(0, verticalScrollOffset, getHorizontalSpace(), verticalScrollOffset + getVerticalSpace()); /** * 将滑出屏幕的Items回收到Recycle缓存中 */ Rect childRect = new Rect(); for (int i = 0; i &lt; getChildCount(); i++) &#123; //这个方法获取的是RecyclerView中的View，注意区别Recycler中的View //这获取的是实际的View View child = getChildAt(i); //下面几个方法能够获取每个View占用的空间的位置信息，包括ItemDecorator childRect.left = getDecoratedLeft(child); childRect.top = getDecoratedTop(child); childRect.right = getDecoratedRight(child); childRect.bottom = getDecoratedBottom(child); //如果Item没有在显示区域，就说明需要回收 if (!Rect.intersects(displayRect, childRect)) &#123; //移除并回收掉滑出屏幕的View removeAndRecycleView(child, recycler); itemStates.put(i, false); //更新该View的状态为未依附 &#125; &#125; //重新显示需要出现在屏幕的子View for (int i = 0; i &lt; getItemCount(); i++) &#123; //判断ItemView的位置和当前显示区域是否重合 if (Rect.intersects(displayRect, allItemRects.get(i))) &#123; //获得Recycler中缓存的View View itemView = recycler.getViewForPosition(i); measureChildWithMargins(itemView, DisplayUtils.getScreenWidth() / 2, 0); //添加View到RecyclerView上 addView(itemView); //取出先前存好的ItemView的位置矩形 Rect rect = allItemRects.get(i); //将这个item布局出来 layoutDecoratedWithMargins(itemView, rect.left, rect.top - verticalScrollOffset, //因为现在是复用View，所以想要显示在 rect.right, rect.bottom - verticalScrollOffset); itemStates.put(i, true); //更新该View的状态为依附 &#125; &#125; LogUtils.e("itemCount = " + getChildCount()); &#125; @Override public boolean canScrollVertically() &#123; // 返回true表示可以纵向滑动 return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //每次滑动时先释放掉所有的View，因为后面调用recycleAndFillView()时会重新addView()。 detachAndScrapAttachedViews(recycler); // 列表向下滚动dy为正，列表向上滚动dy为负，这点与Android坐标系保持一致。 // 实际要滑动的距离 int travel = dy; LogUtils.e("dy = " + dy); // 如果滑动到最顶部 if (verticalScrollOffset + dy &lt; 0) &#123; travel = -verticalScrollOffset; &#125; else if (verticalScrollOffset + dy &gt; totalHeight - getVerticalSpace()) &#123;// 如果滑动到最底部 travel = totalHeight - getVerticalSpace() - verticalScrollOffset; &#125; // 调用该方法通知view在y方向上移动指定距离 offsetChildrenVertical(-travel); recycleAndFillView(recycler, state); //回收并显示View // 将竖直方向的偏移量+travel verticalScrollOffset += travel; return travel; &#125; private int getVerticalSpace() &#123; // 计算RecyclerView的可用高度，除去上下Padding值 return getHeight() - getPaddingBottom() - getPaddingTop(); &#125; @Override public boolean canScrollHorizontally() &#123; // 返回true表示可以横向滑动 return super.canScrollHorizontally(); &#125; @Override public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // 在这个方法中处理水平滑动 return super.scrollHorizontallyBy(dx, recycler, state); &#125; public int getHorizontalSpace() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125;&#125; 实现缓存最主要的就是先把每个ItemView的位置信息保存起来，然后在滑动过程中通过判断每个ItemView的位置是否和当前RecyclerView应该显示的区域有重合，若有就显示它，若没有就移除并回收。 总结实现自己的自定义LayoutManager主要的三个步骤： 计算每个ItemView的位置； 添加滑动事件； 实现缓存。 我们需根据代码多理解，多思考，然后动手写属于自己的LayoutManager。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——生成器模式]]></title>
      <url>%2F2016%2F06%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 实质分离整体构建算法和部件构造。 解释:打魔兽的时候，玩家就相当于Director指导者，兵营就相当于Builder生成器，而Product产品就是各种兵。玩家指导兵营生产不同的兵种，玩家可以通过自己的一些思考(构建算法)决定什么兵生产几个，开始或终止生产，而兵营只负责去构建这些兵种，并且对玩家暴露驱动生产的接口。 模式图解生成器模式UML图从上图可以看出: Director指导者，它拥有Builder构建者，负责实现构建算法，在适合的时候调用Builder创建部件或产品，并且具备配置Builder参数的能力，以便能够动态的创建符合要求的部件或产品； Builder构建者能够根据参数实现具体固定的构建过程，ConcreteBuilder实现了一种具体的构建过程； Product产品接口（不是必要的，在简化的生成器模式中Builder作为静态内部类存在于Product中）。 Talk is cheap, show me the Code. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Directorpublic class Director&#123; private Builder builder; //Director指导者需要持有Builder构建者 public Director(Builder builder)&#123; this.builder = builder; &#125; public void construct()&#123; builder.build(); &#125;&#125;//Builderpublic interface Builder&#123; void build();&#125;//ConcreteBuilderpublic class ConcreteBuilder implements Builder&#123; private Product resultProduct; private String property; public ConcreteBuilder()&#123; &#125; public Product build()&#123; this.resultProduct = new ProductA(); resultProduct.setProperty(property); return resultProduct; &#125; public Product setProperty(String property)&#123; this.property = property; &#125; public Product getResult()&#123; return resultProduct; &#125;&#125;//Product接口public interface Product&#123; &#125;public class ProductA&#123; private String property; public void setProperty(String property)&#123; this.property = property; &#125;&#125; 看看Client客户端如何使用：1234567891011public class Client&#123; publuc static void main(Stringp[] args)&#123; Product product; Builder builder = new ConcreteBuilder(); //创建生成器 buidler.setProperty("property"); Director director = new Director(builder); //创建指导者 director.construct(); //构建产品 product = builder.getResult(); //获得产品实例 &#125;&#125; 构建器模式可以省略Director，直接把Builder作为静态内部类嵌入到产品类中，然后把构建算法放到Client中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Product&#123; private String property1; private String property2; private String property3; private Product()&#123; &#125; private void setProperty1(String property1)&#123; //可在这里对参数进行检查，如： if(property1.equals("condition1"))&#123; System.out.println("property1 is error.") &#125; this.property1 = property1; &#125; private void setProperty2(String property2)&#123; this.property2 = property2; &#125; private void setProperty3(String property3)&#123; this.property3 = property3; &#125; public static class Builder&#123; private String property1; private String property2; private String property3; public Builder setProperty1(String property1)&#123; this.property1 = property1; return this; &#125; public Builder setProperty2(String property2)&#123; this.property2 = property2; return this; &#125; public Builder setProperty3(String property3)&#123; this.property3 = property3; return this; &#125; public Buidler build()&#123; //配置好属性之后，最终调用这个方法来创建对象 //也可在这里对参数进行检查，如： if(property1.equals("condition1"))&#123; System.out.println("property1 is error.") &#125; if(property2.equals("condition2"))&#123; System.out.println("property2 is error.") &#125; if(property3.equals("condition3"))&#123; System.out.println("property3 is error.") &#125; //创建Product Product product = new Product(); product.setProperty1(property1); product.setProperty2(property2); product.setProperty2(property2); return product; &#125; &#125; &#125; 生成器模式顺序图 结合上面代码来看这个图。 模式优缺点优势 松散耦合：将构建算法和构建过程分离，同时也与客户端隔离； 方便修改：由于松散耦合，依赖抽象，所以修改很容易进行； 复用性更好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——适配器模式]]></title>
      <url>%2F2016%2F06%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义将一个类的接口转换为客户希望的另一个接口，适配器模式使原本由于接口不兼容不能一起工作的类，可以在一起工作。 实质类型转换，功能复用。 比较抽象，往下继续看看。 模式图解对象适配器解释： 现在有一个单手剑（现有接口），但英雄只能装备法杖（目标接口）。所以需要定义一个单手剑转换器（适配器），把法杖插进去，它属于单手剑系列，但内部其实是一根法杖（持有现有接口）！当英雄使用单手剑转化器时，实际使用的是法杖。 对象适配器模式UML图从上图可以看出: Target接口为Client客户端所要求的接口； Adapter是适配器，实现了Target接口，持有Adaptee(原始类型，通常它与Client不兼容，但Client又想要使用它的功能)，并且将它适配成了Client要求的Target类型。 来看看原始类型Adaptee123456public class Adaptee&#123; public void specificRequest()&#123; //do something... &#125;&#125; Target接口及Adapter接口123456789101112131415public interface Target&#123; void request();&#125;public class Adapter implements Target&#123; private Adaptee daptee; public Adapter&#123; daptee = new Adaptee(); &#125; public void request()&#123; adaptee.sepcificRequest(); &#125;&#125; Client如何使用12345678public class Client&#123; private Target target; public static void main(String[] args)&#123; target = new Adapter(); //创建适配器，但功能仍然是Adaptee的 target.request(); //实际调用的是Adapter的specificRequest()方法 &#125;&#125; 对象适配器模式顺序图结合上面代码看。 类适配器模式还是上面那个例子，但这次不需要单手剑转换器了，而是直接创建一种即是单手剑，又是法杖的武器（采用多重继承，但是Java世界不支持！）。在Java宇宙中，只能通过继承单手剑，Copy法杖功能来实现。 类适配器模式UML图 从图中可以看到，类适配器模式使用了多重继承的特性，但是Java只支持单继承，所以这种模式在Java中不是太适用； Adapter适配器同时继承了Client所期望的类型Target类，和想要使用的功能类Adaptee类。 客户端只需要调用Adapter继承到的specificRequest()方法即可。 这个模式在Java中不常用，而且顺序图比较简单，就不展示了。 拓展——接口适配器严格来说接口适配器并不是标准的适配器模式，它只是借用了适配器的概念而已。接下来看看它是怎么一回事。 场景:我们可能遇到过这样一种场景，就是一个interface的方法很多，而我们只想使用其中少数几个，并不想直接实现它，然后把所有方法都重写一遍。 解决方法：创建一个abstract抽象类，实现目标接口interface，然后我们就可以继承这个抽象类，选择其中想要的方法去实现逻辑，而不用把所有方法都列出来。 接口适配器模式UML图如图，AbstractAdapter实现了Api，然后Adapter继承AbstractAdapter就可以选择想要的方法重写就好，而不用把所有方法都列出来。它最大的作用其实在写内部类的时候，有的接口要求重写的方法很多，这样会多出很多行无用的代码，这个时候就可以定义一个接口适配器，选择性的列出并重写方法就好。 模式优缺点优势 转换接口，提高复用性； 具有更好的扩展性。我们可以在适配器中扩展新功能，同时还能兼顾老功能。 缺点 使用不合理容易造成迷惑。当我们调用A对象的功能时，其内部其实是调用了B的功能，让人不易理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——外观模式]]></title>
      <url>%2F2016%2F06%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义 为子系统中的一组接口提供一个一致的界面，这个界面使得子系统更加容易使用。 解释：英雄吹响号角（相当于统一界面，用于发动攻击），命令部队对敌军发动攻击；接下来部队里的各种兵种开始对敌军发动攻击。咕噜兵发起了攻击，狼骑发起了攻击，牛头人发起了攻击，风骑士发起了攻击…号角这个统一界面，把部队发起攻击的事件进行了封装，使得英雄不用去了解发起攻击时，部队中的每个兵种是如何发起攻击的。 实质 封装交互，简化调用。 模式图解外观模式UML图从上图可以看出: Facade作为外观类，它提供一个test() 方法入口，供CLient客户端调用子系统功能； 可以看到Facade依赖了子系统中所有类，因为它要负责调度它们；Facade其实就是把子系统的功能封装起来，这样使得Client仅仅通过一个test() 方法就能使用子系统。来看看代码：功能模块的代码:1234567891011121314151617181920212223242526272829303132//A功能模块public interface AMoudleApi&#123; void testA();&#125;public class AMoudle implements AMoudleApi&#123; public void testA()&#123; System.out.println("AMoudle"); &#125;&#125;//B功能模块public interface BMoudleApi&#123; void testB();&#125;public class BMoudle implements BMoudleApi&#123; public void testB()&#123; System.out.println("BMoudle"); &#125;&#125;//A功能模块public interface CMoudleApi&#123; void testC();&#125;public class CMoudle implements CMoudleApi&#123; public void testC()&#123; System.out.println("CMoudle"); &#125;&#125; Facade外观类：12345678910111213141516public class Facade&#123; private AMoudleApi aMoudle; private BMoudleApi bMoudle; private CMoudleApi cMoudle; public Facade&#123; aMoudle = new AMoudle(); bMoudle = new BMoudle(); cMoudle = new CMoudle(); &#125; public void test()&#123; aMoudle.testA(); bMoudle.testB(); cMoudle.testC(); &#125;&#125; 下面看看Client客户端是如何使用的：1234567public class Client&#123; private Facade facade; public static void main(String[] args)&#123; facade = new Facade() facade.test(); //调用Facade的test()方法就能调用到上面所有功能模块，而不用依赖它们 &#125;&#125; 外观模式顺序图结合上面的代码看这个过程图。 模式优缺点优势 松散耦合，使客户端和子系统解耦，似的扩展更容易进行； 简单易用； 更好的划分访问层次。 缺点 使用不合理容易让人不明白是调用Facade接口好，还是直接调用子系统功能接口好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——单例模式的5种实现]]></title>
      <url>%2F2016%2F05%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%845%E7%A7%8D%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[单例模式是我们最常使用，也是最简单的一种模式，主要用于只想系统中存在一个实例的情况，比如某个Manager。 定义及实质 定义确保某一个类只有一个实例，而且自行实例化并向系统提供这个实例。 实质控制实例数量，确保只有一个实例。 模式图解单例模式UML图很直观明了，很简单。下面来看看单例模式的不同实现方案。 饿汉式1234567891011121314151617public class Singleton&#123; private static fianl Singleton instance = new Singleton(); //私有化构造器，避免外部访问。使用反射仍然可以访问，所以安全是相对的。 //但仍然可以通过哈希值等进行限制，提高安全性。 priavte Singleton&#123; &#125; //对外暴露的接口，用于获取实例 public static Singleton getInstance()&#123; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 解释： 饿汉式是利用了static 关键字在类加载时就会进行初始化，并且缓存到静态内存 中的特点，确保了调用getInstance() 时，无须担心instance 为null； 通过fianl 关键字，式单例在多线程情况下的安全，因为JVM会自动对fianl 进行上锁同步。 优点： 能够在线程安全的情况下实现单例。缺点： 由于类一加载就会创建实例，所以会较早占用系统资源。 懒汉式123456789101112131415161718public class Singleton&#123; private static Singleton instance; priavte Singleton&#123; &#125; //加synchronized上锁，可以一定程度上确保安全性 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 解释： 懒汉式体现了延迟加载的的思想。对象实例只有在第一次调用getInstance() 方法时才会被创建，一定程度上的节约了系统资源； 懒汉式在单线程下能够很好的工作，但是并发下就很有可能会创建多个实例。 优点： 能够实现延迟加载，节约内存。在单线程中能很好工作。缺点： 并发下可能会创建多个实例，每次判断都会耗费一些时间。 DCL双重检查实现单例1234567891011121314151617181920212223public class Singleton&#123; //这里使用了volatile关键字，它能够确保insatnce变量每次都直接从主内存(而不是寄存器)中加载最新赋值。 private volatile static Singleton instance = null; priavte Singleton&#123; &#125; //这里进行了两次null检查，即双重检查锁定，这能很大程度的确保安全性 public static Singleton getInstance()&#123; if(instance == null)&#123; synchroniazed(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 优点： 既能很大程度上确保线程安全，又能实现延迟加载。缺点： 使用volatile 关键字会使JVM对该段代码的优化丧失，影响性能。并且在一些高并发的情况下，仍然可能创建多个实例，这称为双重检查锁定失效 ，有一些书中作者均认为这是一种“丑陋”的单例实现方案。 静态内部类实现单例123456789101112131415161718public class Singleton&#123; priavte Singleton&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125; //静态内部类确保了在首次调用getInstance()的时候才会初始化SingletonHolder，从而导致实例被创建。 //并且由JVM保证了线程的安全。 priavte static class SingletonHolder&#123; priavte static final Singleton instance = new Singleton(); &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 这是单例模式最好的实现方法之一。 枚举类实现单例枚举能够确保实例的唯一性，能够最大程度上确保线程安全，并且提供无偿序列化机制。所以在不对延迟加载有太高要求的情况下，使用枚举创建单例是最佳的方案！ 1234567public enum Singleton&#123; INSTANCE; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 拓展以下几种情况下JVM会自动帮助我们完成同步： 静态初始化器(static{}代码块)初始化数据时； 访问final字段时； 在创建线程之前创建对象； 线程可以看见它将要创建的对象时。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——抽象工厂模式]]></title>
      <url>%2F2016%2F05%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式和工厂方法模式很相似，都是延迟子类选择创建，但它们的不同点在于： 工厂方法模式专注于创建单个完整的产品，而抽象工厂模式专注于创建构一个完整产品的所有部件。比如说，工厂方法模式创建一把单手剑，而抽象工厂模式需要创建剑柄、剑体、需要用的材料等。它们思想相同，但关注点不一样。工厂方法模式可以理解为宏观，而抽象工厂模式可以理解为微观。[工厂方法模式传送门] 定义及实质 定义 提供创建一系列相关或相互依赖的对象的接口，而无需指定它们的具体类。 实质 选择产品簇的实现。 模式图解抽象工厂模式UML图从上图可以看出: 首先定义了一个抽象工厂类AbstractFactory，它相当于一个模版，它能够生产具有相关关系的产品A、B，其子类工厂按照这个规范进行扩展； 定义两种产品接口(产品模版)，AbstarctProductA和AbstarctProductB，它们是相关的产品类型，比如说剑柄和剑体； 继承抽象工厂类AbstractFactory，定义两种不同的工厂，分别用于生产1系列产品和2系列产品。下面是工厂类： 12345678910111213141516171819202122232425262728293031//抽象工厂类AbstractFactorypublic abstract class AbstractFactory&#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125;//1系列产品工厂public class ConcreteFactory1&#123; @Overrid public AbstractProductA createProductA()&#123; return new ProductA1(); &#125; @Overrid public AbstractProductB createProductB()&#123; return new ProductB1(); &#125;&#125;//2系列产品工厂public class ConcreteFactory1&#123; @Overrid public AbstractProductA createProductA()&#123; return new ProductA2(); &#125; @Overrid public AbstractProductB createProductB()&#123; return new ProductB2(); &#125;&#125; 下面是产品类： 1234567891011121314151617181920212223242526272829303132333435363738394041//A类产品接口(模版)public interface AbstractProductA&#123; void doSomthing();&#125;//A1产品public class ProductA1 implement AbstractProductA&#123; @Overrid public void doSomething()&#123; System.out.println("ProductA1"); &#125;&#125;//A2产品public class ProductA2 implement AbstractProductA&#123; @Overrid public void doSomething()&#123; System.out.println("ProductA2"); &#125;&#125;//B类产品接口(模版)public interface AbstractProductB&#123; void doSomthing();&#125;//B1产品public class ProductB1 implement AbstractProductB&#123; @Overrid public void doSomething()&#123; System.out.println("ProductB1"); &#125;&#125;//B2产品public class ProductB2 implement AbstractProductB&#123; @Overrid public void doSomething()&#123; System.out.println("ProductB2"); &#125;&#125; 下面看看Client客户端如何使用： 12345678910111213public class Client&#123; public static void main(String[] args)&#123; //现在需要创建1系列产品 AbstractFactory factory = new ConcreteFactory1(); ProductA a1 = factory.createProductA(); ProductB b1 = factory.createProductB(); //接下来创建2系列产品 factory = new ConcreteFactory2(); ProductA a2 = factory.createProductA(); ProductB b2 = factory.createProductB(); &#125;&#125; 抽象工厂模式顺序图结合上面代码来看顺序图。 模式优缺点优势 封装复杂创建逻辑； 解耦Client和产品； 方便切换产品簇，只需更换工厂实例就行。 缺点 不容易扩展新产品，当需要增加新的产品类型时，不得不把之前的每个工厂类都修改； 容易造成选择层次的复杂，因为当产品类型多时，配置方案也将增加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——工厂方法模式]]></title>
      <url>%2F2016%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[工厂方法模式和简单工厂模式本质是类似的，都是用来封装产品的创建过程。但它们的实现也有很大的，所以通常被作为两种不同的设计模式看待。 定义及实质 定义定义一个用于创建对象的接口，让子类决定实例化那一个对象，即使一个类的实现延迟到子类实现。 实质延迟到子类选择实现。 虽然都是选择实现，但工厂方法模式主要用于创建一系列的产品簇(就是相似的东西)，而简单工厂法可以创建任何互相没有关联的实例。 模式图解工厂方法模式UML图从上图可以看出： Creator是抽象父类，ConcreteCreator是其子类； ConcreteCreator重写了父类的factoryMethod() 来创建真正的产品ConcreteProduct，也就是说ConcreteCreator依赖ConcreteProduct；需要注意，Creator依赖的是Product； ConcreteProduct实现了Product接口。1234567891011121314151617181920212223242526272829//Creatorpublic abstract class Creator&#123; public abstrat Product factoryMethod(); public void someOpration()&#123; //在这里延迟创建了Product factorMethod().doSomthing(); &#125;&#125;//ConcreteCreatorpublic class ConcreteCreator extends Creator&#123; @Overrid public Product factoryMethod()&#123; return new ConcreteProduct(); &#125;&#125;//Productpublic interface Product&#123; void doSomthing();&#125;//public class ConcreteProduct implement Product&#123; @Overrid public void doSomthing()&#123; System.out.println("ConcreteProduct"); &#125;&#125; 下面看看Client怎么使用:1234567public class Client&#123; priavte Creator creator; public static void main(String[] args)&#123; creator = new ConcreteCreator(); //创建符合需求的Creator子类 creator.someOpration(); //调用这个方法才会创建Product &#125;&#125; 工厂方法模式顺序图结合上面的代码看。 模式优缺点优势 体现了依赖倒置 的原则，使程序的可扩展性增强，当有新需求时，只需要增加新的Creator子类，替换Client中的子类，而不需要修改其它地方； 可以在不知道对象创建过程未确定的情况下进行编程； 可以很好的链接平行类层次结构。 工厂类和产品类耦合在一起。 拓展平行类层次结构指一个类层级(工厂方法模式中，每个Creator的抽象就代表着一个类层级)中的每一个类，在另一个类层级中都有对应的类与之呼应，这样的一组类层就称为平行类层次结构 。解释：以Shape为例，具体的Shape对象和Shape对象的行为就构成了平行类层次结构。Shape对象层级中有Rectangle、Oval等，在Shape对象行为层级中，有Rectangle、Oval等的面积、周长等行为与之对应。所以它们构成了平行类层次结构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——简单工厂模式]]></title>
      <url>%2F2016%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义提供一个创建对象实例的功能(接口)，而客户调用时无须关心实现过程。属于创建型模式。 实质选择实现。 模式图解简单工厂模式UML图解释：从上图可以看出: Factory依赖了Api接口和两个接口的实现类; 而Client依赖Factory和Api接口； ImpA和ImpB是Api接口的不同实现； Factory工厂类承担了对象实例的创建，而Client只需调用Factory提供的方法(通常是静态方法)就可以获取相应的对象实例，Client完全不清楚对象是如何创建的。这种模式实现了用户和对象的解耦，当对象发生变化时，我们无须改动用户的调用，只需在Factory中修改或增加就可以。 // 对象 public interface Api{ public void doSomething(); } public ImpA implements Api{ @Override public void doSomthing(){ System.out.println("这里是ImpA"); } } public ImpB implements Api{ @Override public void doSomthing(){ System.out.println("这里是ImpB"); } } // Factory public class ApiFactory{ public static Api getApi(int type){ Api api = null; if(type == 0){ api = new ImpA(); } else if(type == 1){ api = new ImpB(); } return api; } } // Client public class Client{ Api api; public client(){ // 注意，这里用户并不知道它所获得的对象实例是怎么创建的。 api = Factory.getApi(0); if(api != null){ api.doSomthing(); } } } 简单工厂模式顺序图结合上面代码来看。 模式优缺点优势 封装：封装用户创建对象实例的过程。 解耦：使用户不用去关心对象实例的创建过程，并且依赖于抽象。 缺点用户往往需要知道Factory中选择参数的意义。]]></content>
    </entry>

    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式——生成器模式]]></title>
      <url>%2F2016%2F06%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 实质分离整体构建算法和部件构造。 解释:打魔兽的时候，玩家就相当于Director指导者，兵营就相当于Builder生成器，而Product产品就是各种兵。玩家指导兵营生产不同的兵种，玩家可以通过自己的一些思考(构建算法)决定什么兵生产几个，开始或终止生产，而兵营只负责去构建这些兵种，并且对玩家暴露驱动生产的接口。 模式图解生成器模式UML图从上图可以看出: Director指导者，它拥有Builder构建者，负责实现构建算法，在适合的时候调用Builder创建部件或产品，并且具备配置Builder参数的能力，以便能够动态的创建符合要求的部件或产品； Builder构建者能够根据参数实现具体固定的构建过程，ConcreteBuilder实现了一种具体的构建过程； Product产品接口（不是必要的，在简化的生成器模式中Builder作为静态内部类存在于Product中）。 Talk is cheap, show me the Code. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//Directorpublic class Director&#123; private Builder builder; //Director指导者需要持有Builder构建者 public Director(Builder builder)&#123; this.builder = builder; &#125; public void construct()&#123; builder.build(); &#125;&#125;//Builderpublic interface Builder&#123; void build();&#125;//ConcreteBuilderpublic class ConcreteBuilder implements Builder&#123; private Product resultProduct; private String property; public ConcreteBuilder()&#123; &#125; public Product build()&#123; this.resultProduct = new ProductA(); resultProduct.setProperty(property); return resultProduct; &#125; public Product setProperty(String property)&#123; this.property = property; &#125; public Product getResult()&#123; return resultProduct; &#125;&#125;//Product接口public interface Product&#123; &#125;public class ProductA&#123; private String property; public void setProperty(String property)&#123; this.property = property; &#125;&#125; 看看Client客户端如何使用：1234567891011public class Client&#123; publuc static void main(Stringp[] args)&#123; Product product; Builder builder = new ConcreteBuilder(); //创建生成器 buidler.setProperty("property"); Director director = new Director(builder); //创建指导者 director.construct(); //构建产品 product = builder.getResult(); //获得产品实例 &#125;&#125; 构建器模式可以省略Director，直接把Builder作为静态内部类嵌入到产品类中，然后把构建算法放到Client中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Product&#123; private String property1; private String property2; private String property3; private Product()&#123; &#125; private void setProperty1(String property1)&#123; //可在这里对参数进行检查，如： if(property1.equals("condition1"))&#123; System.out.println("property1 is error.") &#125; this.property1 = property1; &#125; private void setProperty2(String property2)&#123; this.property2 = property2; &#125; private void setProperty3(String property3)&#123; this.property3 = property3; &#125; public static class Builder&#123; private String property1; private String property2; private String property3; public Builder setProperty1(String property1)&#123; this.property1 = property1; return this; &#125; public Builder setProperty2(String property2)&#123; this.property2 = property2; return this; &#125; public Builder setProperty3(String property3)&#123; this.property3 = property3; return this; &#125; public Buidler build()&#123; //配置好属性之后，最终调用这个方法来创建对象 //也可在这里对参数进行检查，如： if(property1.equals("condition1"))&#123; System.out.println("property1 is error.") &#125; if(property2.equals("condition2"))&#123; System.out.println("property2 is error.") &#125; if(property3.equals("condition3"))&#123; System.out.println("property3 is error.") &#125; //创建Product Product product = new Product(); product.setProperty1(property1); product.setProperty2(property2); product.setProperty2(property2); return product; &#125; &#125; &#125; 生成器模式顺序图 结合上面代码来看这个图。 模式优缺点优势 松散耦合：将构建算法和构建过程分离，同时也与客户端隔离； 方便修改：由于松散耦合，依赖抽象，所以修改很容易进行； 复用性更好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——适配器模式]]></title>
      <url>%2F2016%2F06%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义将一个类的接口转换为客户希望的另一个接口，适配器模式使原本由于接口不兼容不能一起工作的类，可以在一起工作。 实质类型转换，功能复用。 比较抽象，往下继续看看。 模式图解对象适配器解释： 现在有一个单手剑（现有接口），但英雄只能装备法杖（目标接口）。所以需要定义一个单手剑转换器（适配器），把法杖插进去，它属于单手剑系列，但内部其实是一根法杖（持有现有接口）！当英雄使用单手剑转化器时，实际使用的是法杖。 对象适配器模式UML图从上图可以看出: Target接口为Client客户端所要求的接口； Adapter是适配器，实现了Target接口，持有Adaptee(原始类型，通常它与Client不兼容，但Client又想要使用它的功能)，并且将它适配成了Client要求的Target类型。 来看看原始类型Adaptee123456public class Adaptee&#123; public void specificRequest()&#123; //do something... &#125;&#125; Target接口及Adapter接口123456789101112131415public interface Target&#123; void request();&#125;public class Adapter implements Target&#123; private Adaptee daptee; public Adapter&#123; daptee = new Adaptee(); &#125; public void request()&#123; adaptee.sepcificRequest(); &#125;&#125; Client如何使用12345678public class Client&#123; private Target target; public static void main(String[] args)&#123; target = new Adapter(); //创建适配器，但功能仍然是Adaptee的 target.request(); //实际调用的是Adapter的specificRequest()方法 &#125;&#125; 对象适配器模式顺序图结合上面代码看。 类适配器模式还是上面那个例子，但这次不需要单手剑转换器了，而是直接创建一种即是单手剑，又是法杖的武器（采用多重继承，但是Java世界不支持！）。在Java宇宙中，只能通过继承单手剑，Copy法杖功能来实现。 类适配器模式UML图 从图中可以看到，类适配器模式使用了多重继承的特性，但是Java只支持单继承，所以这种模式在Java中不是太适用； Adapter适配器同时继承了Client所期望的类型Target类，和想要使用的功能类Adaptee类。 客户端只需要调用Adapter继承到的specificRequest()方法即可。 这个模式在Java中不常用，而且顺序图比较简单，就不展示了。 拓展——接口适配器严格来说接口适配器并不是标准的适配器模式，它只是借用了适配器的概念而已。接下来看看它是怎么一回事。 场景:我们可能遇到过这样一种场景，就是一个interface的方法很多，而我们只想使用其中少数几个，并不想直接实现它，然后把所有方法都重写一遍。 解决方法：创建一个abstract抽象类，实现目标接口interface，然后我们就可以继承这个抽象类，选择其中想要的方法去实现逻辑，而不用把所有方法都列出来。 接口适配器模式UML图如图，AbstractAdapter实现了Api，然后Adapter继承AbstractAdapter就可以选择想要的方法重写就好，而不用把所有方法都列出来。它最大的作用其实在写内部类的时候，有的接口要求重写的方法很多，这样会多出很多行无用的代码，这个时候就可以定义一个接口适配器，选择性的列出并重写方法就好。 模式优缺点优势 转换接口，提高复用性； 具有更好的扩展性。我们可以在适配器中扩展新功能，同时还能兼顾老功能。 缺点 使用不合理容易造成迷惑。当我们调用A对象的功能时，其内部其实是调用了B的功能，让人不易理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——外观模式]]></title>
      <url>%2F2016%2F06%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义 为子系统中的一组接口提供一个一致的界面，这个界面使得子系统更加容易使用。 解释：英雄吹响号角（相当于统一界面，用于发动攻击），命令部队对敌军发动攻击；接下来部队里的各种兵种开始对敌军发动攻击。咕噜兵发起了攻击，狼骑发起了攻击，牛头人发起了攻击，风骑士发起了攻击…号角这个统一界面，把部队发起攻击的事件进行了封装，使得英雄不用去了解发起攻击时，部队中的每个兵种是如何发起攻击的。 实质 封装交互，简化调用。 模式图解外观模式UML图从上图可以看出: Facade作为外观类，它提供一个test() 方法入口，供CLient客户端调用子系统功能； 可以看到Facade依赖了子系统中所有类，因为它要负责调度它们；Facade其实就是把子系统的功能封装起来，这样使得Client仅仅通过一个test() 方法就能使用子系统。来看看代码：功能模块的代码:1234567891011121314151617181920212223242526272829303132//A功能模块public interface AMoudleApi&#123; void testA();&#125;public class AMoudle implements AMoudleApi&#123; public void testA()&#123; System.out.println("AMoudle"); &#125;&#125;//B功能模块public interface BMoudleApi&#123; void testB();&#125;public class BMoudle implements BMoudleApi&#123; public void testB()&#123; System.out.println("BMoudle"); &#125;&#125;//A功能模块public interface CMoudleApi&#123; void testC();&#125;public class CMoudle implements CMoudleApi&#123; public void testC()&#123; System.out.println("CMoudle"); &#125;&#125; Facade外观类：12345678910111213141516public class Facade&#123; private AMoudleApi aMoudle; private BMoudleApi bMoudle; private CMoudleApi cMoudle; public Facade&#123; aMoudle = new AMoudle(); bMoudle = new BMoudle(); cMoudle = new CMoudle(); &#125; public void test()&#123; aMoudle.testA(); bMoudle.testB(); cMoudle.testC(); &#125;&#125; 下面看看Client客户端是如何使用的：1234567public class Client&#123; private Facade facade; public static void main(String[] args)&#123; facade = new Facade() facade.test(); //调用Facade的test()方法就能调用到上面所有功能模块，而不用依赖它们 &#125;&#125; 外观模式顺序图结合上面的代码看这个过程图。 模式优缺点优势 松散耦合，使客户端和子系统解耦，似的扩展更容易进行； 简单易用； 更好的划分访问层次。 缺点 使用不合理容易让人不明白是调用Facade接口好，还是直接调用子系统功能接口好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——单例模式的5种实现]]></title>
      <url>%2F2016%2F05%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%845%E7%A7%8D%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[单例模式是我们最常使用，也是最简单的一种模式，主要用于只想系统中存在一个实例的情况，比如某个Manager。 定义及实质 定义确保某一个类只有一个实例，而且自行实例化并向系统提供这个实例。 实质控制实例数量，确保只有一个实例。 模式图解单例模式UML图很直观明了，很简单。下面来看看单例模式的不同实现方案。 饿汉式1234567891011121314151617public class Singleton&#123; private static fianl Singleton instance = new Singleton(); //私有化构造器，避免外部访问。使用反射仍然可以访问，所以安全是相对的。 //但仍然可以通过哈希值等进行限制，提高安全性。 priavte Singleton&#123; &#125; //对外暴露的接口，用于获取实例 public static Singleton getInstance()&#123; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 解释： 饿汉式是利用了static 关键字在类加载时就会进行初始化，并且缓存到静态内存 中的特点，确保了调用getInstance() 时，无须担心instance 为null； 通过fianl 关键字，式单例在多线程情况下的安全，因为JVM会自动对fianl 进行上锁同步。 优点： 能够在线程安全的情况下实现单例。缺点： 由于类一加载就会创建实例，所以会较早占用系统资源。 懒汉式123456789101112131415161718public class Singleton&#123; private static Singleton instance; priavte Singleton&#123; &#125; //加synchronized上锁，可以一定程度上确保安全性 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 解释： 懒汉式体现了延迟加载的的思想。对象实例只有在第一次调用getInstance() 方法时才会被创建，一定程度上的节约了系统资源； 懒汉式在单线程下能够很好的工作，但是并发下就很有可能会创建多个实例。 优点： 能够实现延迟加载，节约内存。在单线程中能很好工作。缺点： 并发下可能会创建多个实例，每次判断都会耗费一些时间。 DCL双重检查实现单例1234567891011121314151617181920212223public class Singleton&#123; //这里使用了volatile关键字，它能够确保insatnce变量每次都直接从主内存(而不是寄存器)中加载最新赋值。 private volatile static Singleton instance = null; priavte Singleton&#123; &#125; //这里进行了两次null检查，即双重检查锁定，这能很大程度的确保安全性 public static Singleton getInstance()&#123; if(instance == null)&#123; synchroniazed(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 优点： 既能很大程度上确保线程安全，又能实现延迟加载。缺点： 使用volatile 关键字会使JVM对该段代码的优化丧失，影响性能。并且在一些高并发的情况下，仍然可能创建多个实例，这称为双重检查锁定失效 ，有一些书中作者均认为这是一种“丑陋”的单例实现方案。 静态内部类实现单例123456789101112131415161718public class Singleton&#123; priavte Singleton&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125; //静态内部类确保了在首次调用getInstance()的时候才会初始化SingletonHolder，从而导致实例被创建。 //并且由JVM保证了线程的安全。 priavte static class SingletonHolder&#123; priavte static final Singleton instance = new Singleton(); &#125; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 这是单例模式最好的实现方法之一。 枚举类实现单例枚举能够确保实例的唯一性，能够最大程度上确保线程安全，并且提供无偿序列化机制。所以在不对延迟加载有太高要求的情况下，使用枚举创建单例是最佳的方案！ 1234567public enum Singleton&#123; INSTANCE; public void doSomething()&#123; System.out.println("doSomething"); &#125;&#125; 拓展以下几种情况下JVM会自动帮助我们完成同步： 静态初始化器(static{}代码块)初始化数据时； 访问final字段时； 在创建线程之前创建对象； 线程可以看见它将要创建的对象时。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——抽象工厂模式]]></title>
      <url>%2F2016%2F05%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式和工厂方法模式很相似，都是延迟子类选择创建，但它们的不同点在于： 工厂方法模式专注于创建单个完整的产品，而抽象工厂模式专注于创建构一个完整产品的所有部件。比如说，工厂方法模式创建一把单手剑，而抽象工厂模式需要创建剑柄、剑体、需要用的材料等。它们思想相同，但关注点不一样。工厂方法模式可以理解为宏观，而抽象工厂模式可以理解为微观。[工厂方法模式传送门] 定义及实质 定义 提供创建一系列相关或相互依赖的对象的接口，而无需指定它们的具体类。 实质 选择产品簇的实现。 模式图解抽象工厂模式UML图从上图可以看出: 首先定义了一个抽象工厂类AbstractFactory，它相当于一个模版，它能够生产具有相关关系的产品A、B，其子类工厂按照这个规范进行扩展； 定义两种产品接口(产品模版)，AbstarctProductA和AbstarctProductB，它们是相关的产品类型，比如说剑柄和剑体； 继承抽象工厂类AbstractFactory，定义两种不同的工厂，分别用于生产1系列产品和2系列产品。下面是工厂类： 12345678910111213141516171819202122232425262728293031//抽象工厂类AbstractFactorypublic abstract class AbstractFactory&#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125;//1系列产品工厂public class ConcreteFactory1&#123; @Overrid public AbstractProductA createProductA()&#123; return new ProductA1(); &#125; @Overrid public AbstractProductB createProductB()&#123; return new ProductB1(); &#125;&#125;//2系列产品工厂public class ConcreteFactory1&#123; @Overrid public AbstractProductA createProductA()&#123; return new ProductA2(); &#125; @Overrid public AbstractProductB createProductB()&#123; return new ProductB2(); &#125;&#125; 下面是产品类： 1234567891011121314151617181920212223242526272829303132333435363738394041//A类产品接口(模版)public interface AbstractProductA&#123; void doSomthing();&#125;//A1产品public class ProductA1 implement AbstractProductA&#123; @Overrid public void doSomething()&#123; System.out.println("ProductA1"); &#125;&#125;//A2产品public class ProductA2 implement AbstractProductA&#123; @Overrid public void doSomething()&#123; System.out.println("ProductA2"); &#125;&#125;//B类产品接口(模版)public interface AbstractProductB&#123; void doSomthing();&#125;//B1产品public class ProductB1 implement AbstractProductB&#123; @Overrid public void doSomething()&#123; System.out.println("ProductB1"); &#125;&#125;//B2产品public class ProductB2 implement AbstractProductB&#123; @Overrid public void doSomething()&#123; System.out.println("ProductB2"); &#125;&#125; 下面看看Client客户端如何使用： 12345678910111213public class Client&#123; public static void main(String[] args)&#123; //现在需要创建1系列产品 AbstractFactory factory = new ConcreteFactory1(); ProductA a1 = factory.createProductA(); ProductB b1 = factory.createProductB(); //接下来创建2系列产品 factory = new ConcreteFactory2(); ProductA a2 = factory.createProductA(); ProductB b2 = factory.createProductB(); &#125;&#125; 抽象工厂模式顺序图结合上面代码来看顺序图。 模式优缺点优势 封装复杂创建逻辑； 解耦Client和产品； 方便切换产品簇，只需更换工厂实例就行。 缺点 不容易扩展新产品，当需要增加新的产品类型时，不得不把之前的每个工厂类都修改； 容易造成选择层次的复杂，因为当产品类型多时，配置方案也将增加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——工厂方法模式]]></title>
      <url>%2F2016%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[工厂方法模式和简单工厂模式本质是类似的，都是用来封装产品的创建过程。但它们的实现也有很大的，所以通常被作为两种不同的设计模式看待。 定义及实质 定义定义一个用于创建对象的接口，让子类决定实例化那一个对象，即使一个类的实现延迟到子类实现。 实质延迟到子类选择实现。 虽然都是选择实现，但工厂方法模式主要用于创建一系列的产品簇(就是相似的东西)，而简单工厂法可以创建任何互相没有关联的实例。 模式图解工厂方法模式UML图从上图可以看出： Creator是抽象父类，ConcreteCreator是其子类； ConcreteCreator重写了父类的factoryMethod() 来创建真正的产品ConcreteProduct，也就是说ConcreteCreator依赖ConcreteProduct；需要注意，Creator依赖的是Product； ConcreteProduct实现了Product接口。1234567891011121314151617181920212223242526272829//Creatorpublic abstract class Creator&#123; public abstrat Product factoryMethod(); public void someOpration()&#123; //在这里延迟创建了Product factorMethod().doSomthing(); &#125;&#125;//ConcreteCreatorpublic class ConcreteCreator extends Creator&#123; @Overrid public Product factoryMethod()&#123; return new ConcreteProduct(); &#125;&#125;//Productpublic interface Product&#123; void doSomthing();&#125;//public class ConcreteProduct implement Product&#123; @Overrid public void doSomthing()&#123; System.out.println("ConcreteProduct"); &#125;&#125; 下面看看Client怎么使用:1234567public class Client&#123; priavte Creator creator; public static void main(String[] args)&#123; creator = new ConcreteCreator(); //创建符合需求的Creator子类 creator.someOpration(); //调用这个方法才会创建Product &#125;&#125; 工厂方法模式顺序图结合上面的代码看。 模式优缺点优势 体现了依赖倒置 的原则，使程序的可扩展性增强，当有新需求时，只需要增加新的Creator子类，替换Client中的子类，而不需要修改其它地方； 可以在不知道对象创建过程未确定的情况下进行编程； 可以很好的链接平行类层次结构。 工厂类和产品类耦合在一起。 拓展平行类层次结构指一个类层级(工厂方法模式中，每个Creator的抽象就代表着一个类层级)中的每一个类，在另一个类层级中都有对应的类与之呼应，这样的一组类层就称为平行类层次结构 。解释：以Shape为例，具体的Shape对象和Shape对象的行为就构成了平行类层次结构。Shape对象层级中有Rectangle、Oval等，在Shape对象行为层级中，有Rectangle、Oval等的面积、周长等行为与之对应。所以它们构成了平行类层次结构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——简单工厂模式]]></title>
      <url>%2F2016%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[定义及实质 定义提供一个创建对象实例的功能(接口)，而客户调用时无须关心实现过程。属于创建型模式。 实质选择实现。 模式图解简单工厂模式UML图解释：从上图可以看出: Factory依赖了Api接口和两个接口的实现类; 而Client依赖Factory和Api接口； ImpA和ImpB是Api接口的不同实现； Factory工厂类承担了对象实例的创建，而Client只需调用Factory提供的方法(通常是静态方法)就可以获取相应的对象实例，Client完全不清楚对象是如何创建的。这种模式实现了用户和对象的解耦，当对象发生变化时，我们无须改动用户的调用，只需在Factory中修改或增加就可以。 // 对象 public interface Api{ public void doSomething(); } public ImpA implements Api{ @Override public void doSomthing(){ System.out.println("这里是ImpA"); } } public ImpB implements Api{ @Override public void doSomthing(){ System.out.println("这里是ImpB"); } } // Factory public class ApiFactory{ public static Api getApi(int type){ Api api = null; if(type == 0){ api = new ImpA(); } else if(type == 1){ api = new ImpB(); } return api; } } // Client public class Client{ Api api; public client(){ // 注意，这里用户并不知道它所获得的对象实例是怎么创建的。 api = Factory.getApi(0); if(api != null){ api.doSomthing(); } } } 简单工厂模式顺序图结合上面代码来看。 模式优缺点优势 封装：封装用户创建对象实例的过程。 解耦：使用户不用去关心对象实例的创建过程，并且依赖于抽象。 缺点用户往往需要知道Factory中选择参数的意义。]]></content>
    </entry>

    
  
  
</search>
